<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>üê§ vs üê∏</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #e0e5ec;
      --shadow-d: #a3b1c6;
      --shadow-l: #ffffff;
      --duck-color: rgba(247, 220, 111, 0.4);
      --frog-color: rgba(139, 195, 74, 0.4);
      --divider-color: rgba(120, 130, 150, 0.3);
    }
    html, body { 
      height: 100%; 
      overflow: hidden;
      touch-action: manipulation;
    }
    body {
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', system-ui, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 10px;
    }

    /* HUD */
    .hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 320px;
      margin-bottom: 10px;
      gap: 10px;
    }
    .player-info {
      flex: 1;
      padding: 10px 15px;
      border-radius: 16px;
      background: var(--bg);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .player-info.duck { border: 2px solid var(--duck-color); }
    .player-info.frog { border: 2px solid var(--frog-color); }
    .player-icon { font-size: 1.5rem; }
    .player-hp {
      font-size: 1.2rem;
      font-weight: 700;
      color: #e74c3c;
    }
    .player-totem {
      font-size: 0.9rem;
      opacity: 0.7;
    }

    /* Board */
    .board-container {
      position: relative;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(15, 1fr);
      gap: 3px;
      width: min(calc(100vw - 20px), 300px);
      aspect-ratio: 9 / 15;
      padding: 8px;
      border-radius: 16px;
      background: var(--bg);
      box-shadow: 
        8px 8px 16px var(--shadow-d),
        -8px -8px 16px var(--shadow-l);
    }

    /* Tiles */
    .tile {
      border-radius: 6px;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      cursor: pointer;
      position: relative;
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l);
      transition: transform 0.1s, box-shadow 0.1s;
      border: 2px solid transparent;
    }
    .tile:active {
      transform: scale(0.95);
      box-shadow: 
        inset 2px 2px 4px var(--shadow-d),
        inset -2px -2px 4px var(--shadow-l);
    }
    
    /* Divider diagonal - tiles on the diagonal line */
    .tile.divider {
      border: 2px solid rgba(120, 130, 150, 0.5);
    }

    /* King zones */
    .tile.duck-zone {
      border-color: var(--duck-color);
    }
    .tile.frog-zone {
      border-color: var(--frog-color);
    }

    /* Kings */
    .tile.king {
      grid-column: span 2;
      grid-row: span 2;
      font-size: 2rem;
      cursor: default;
      border-radius: 10px;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .tile.duck-king {
      grid-column: 8 / 10;
      grid-row: 1 / 3;
      border: 3px solid var(--duck-color);
    }
    .tile.frog-king {
      grid-column: 1 / 3;
      grid-row: 14 / 16;
      border: 3px solid var(--frog-color);
    }

    /* Game objects */
    .tile.obstacle {
      background: rgba(200, 200, 200, 0.5);
    }
    .tile.obstacle.breaking {
      animation: obstacle-break 0.3s ease-out;
    }
    @keyframes obstacle-break {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    .tile.obstacle.cant-break {
      animation: obstacle-shake 0.3s ease-out;
    }
    @keyframes obstacle-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }
    
    .tile.player {
      z-index: 10;
      box-shadow: 
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    
    /* Animated player sprites */
    .player-sprite {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: var(--bg);
      z-index: 20;
      pointer-events: none;
      transition: left 0.3s ease-out, top 0.3s ease-out;
      box-shadow: 
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    .player-sprite .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .player-sprite .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 0.6rem;
      background: white;
      border-radius: 50%;
      padding: 2px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    
    .tile.ally {
      font-size: 0.7rem;
      opacity: 0.8;
    }
    .tile.ally.breaking {
      animation: obstacle-break 0.3s ease-out;
    }
    
    /* Path visualization for allies */
    .tile.ally-path-duck::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(247, 220, 111, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    .tile.ally-path-frog::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(139, 195, 74, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    
    /* Player target path visualization */
    .tile.player-path {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        inset 0 0 8px rgba(100, 150, 255, 0.4);
    }
    .tile.totem {
      animation: totem-glow 2s ease-in-out infinite;
    }
    @keyframes totem-glow {
      0%, 100% { box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l); }
      50% { box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l), 0 0 10px rgba(255, 215, 0, 0.5); }
    }

    /* Highlight for valid moves */
    .tile.highlight {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        0 0 0 3px rgba(100, 200, 100, 0.5);
    }

    /* Totem indicator on player */
    .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 0.6rem;
      background: white;
      border-radius: 50%;
      padding: 2px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    /* HP badge on player */
    .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    /* Controls */
    .controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: #333;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .btn:active {
      box-shadow: 
        inset 3px 3px 6px var(--shadow-d),
        inset -3px -3px 6px var(--shadow-l);
    }

    /* Turn indicator */
    .turn-info {
      margin-top: 10px;
      font-size: 0.8rem;
      color: #666;
      text-align: center;
    }

    /* Winner modal */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: var(--bg);
      padding: 30px 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 
        10px 10px 20px var(--shadow-d),
        -10px -10px 20px var(--shadow-l);
    }
    .modal-content h2 {
      font-size: 2rem;
      margin-bottom: 10px;
    }
    .modal-content p {
      font-size: 1rem;
      color: #666;
      margin-bottom: 20px;
    }
    
    /* Character selection */
    .select-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
    }
    .select-btn {
      padding: 20px 30px;
      border: none;
      border-radius: 16px;
      background: var(--bg);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      transition: all 0.2s;
    }
    .select-btn:hover {
      transform: scale(1.05);
    }
    .select-btn:active {
      box-shadow: 
        inset 4px 4px 8px var(--shadow-d),
        inset -4px -4px 8px var(--shadow-l);
    }
    .select-btn.duck-select:hover {
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--duck-color);
    }
    .select-btn.frog-select:hover {
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--frog-color);
    }
    .select-icon {
      font-size: 3rem;
    }
    .select-name {
      font-size: 1rem;
      font-weight: 600;
      color: #333;
    }
    
    /* AI indicator */
    .player-info.ai::after {
      content: 'ü§ñ';
      margin-left: 5px;
    }
  </style>
</head>
<body>

<!-- Character Selection Modal -->
<div class="modal show" id="selectModal">
  <div class="modal-content">
    <h2>üéÆ –û–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
    <p>–ó–∞ –∫–æ–≥–æ –±—É–¥–µ—à –≥—Ä–∞—Ç–∏?</p>
    <div class="select-buttons">
      <button class="select-btn duck-select" onclick="selectCharacter('duck')">
        <span class="select-icon">üê§</span>
        <span class="select-name">–ö–∞—á–µ–Ω—è</span>
      </button>
      <button class="select-btn frog-select" onclick="selectCharacter('frog')">
        <span class="select-icon">üê∏</span>
        <span class="select-name">–ñ–∞–±–∫–∞</span>
      </button>
    </div>
  </div>
</div>

<!-- HUD -->
<div class="hud">
  <div class="player-info duck">
    <span class="player-icon">üê§</span>
    <span class="player-hp" id="duckHp">‚ù§Ô∏è 1</span>
    <span class="player-totem" id="duckTotem"></span>
  </div>
  <div class="player-info frog">
    <span class="player-icon">üê∏</span>
    <span class="player-hp" id="frogHp">‚ù§Ô∏è 1</span>
    <span class="player-totem" id="frogTotem"></span>
  </div>
</div>

<!-- Board -->
<div class="board-container">
  <div class="board" id="board"></div>
  <div class="player-sprite" id="duckSprite">üê•<span class="hp-badge" id="duckSpriteBadge">1</span></div>
  <div class="player-sprite" id="frogSprite">üê∏<span class="hp-badge" id="frogSpriteBadge">1</span></div>
</div>

<!-- Controls -->
<div class="controls">
  <button class="btn" onclick="resetGame()">üîÑ –ù–æ–≤–∞ –≥—Ä–∞</button>
</div>

<div class="turn-info" id="turnInfo">–¢—ñ–∫: 0 | –ö–ª—ñ–∫–Ω–∏ –Ω–∞ –ø–ª–∏—Ç–∫—É —â–æ–± —Ä—É—Ö–∞—Ç–∏—Å—å</div>

<!-- Winner Modal -->
<div class="modal" id="winModal">
  <div class="modal-content">
    <h2 id="winnerText">üèÜ</h2>
    <p id="winnerDesc">–ü–µ—Ä–µ–º—ñ–≥!</p>
    <button class="btn" onclick="resetGame(); closeModal();">–ì—Ä–∞—Ç–∏ –∑–Ω–æ–≤—É</button>
  </div>
</div>

<script>
// ============ CONSTANTS ============
const COLS = 9, ROWS = 15;
const TICK_MS = 1500;
const ALLY_SPAWN_TICKS = 4; // 6 sec / 1.5 sec = 4 ticks
const OBSTACLE_DENSITY = 0.3; // 30% chance per valid tile

// Diagonal divider from (col 0, row 3) to (col 8, row 11) in 0-indexed
// In 1-indexed: (1, 4) to (9, 12)

// Emoji
const EMOJI = {
  duckKing: 'üê§',
  frogKing: 'üê∏',
  duckPlayer: 'üê•',
  frogPlayer: 'üê∏',
  duckAlly: 'üê£',
  frogAlly: 'üê∏',
  snakeTotem: 'üêç',
  duckTotem: 'ü¶Ü',
  wave: 'üåä',
  bush: 'üåø'
};

// ============ GAME STATE ============
let game = {
  tick: 0,
  tickTimer: null,
  
  humanPlayer: null, // 'duck' or 'frog'
  aiPlayer: null,    // opposite of humanPlayer
  
  players: {
    duck: { row: 0, col: 5, hp: 1, hasTotem: false, targetPath: [] },
    frog: { row: 14, col: 3, hp: 1, hasTotem: false, targetPath: [] }
  },
  
  totems: {
    snake: { row: 0, col: 0, owner: 'frog', pickedBy: null },
    duck: { row: 14, col: 8, owner: 'duck', pickedBy: null }
  },
  
  allies: [],
  allyPaths: {}, // Store paths for visualization
  obstacles: [],
  
  gameOver: false,
  gameStarted: false
};

// ============ HELPERS ============
const isKingTile = (r, c) => {
  // Duck king: cols 7-8, rows 0-1
  if (c >= 7 && c <= 8 && r >= 0 && r <= 1) return 'duck';
  // Frog king: cols 0-1, rows 13-14
  if (c >= 0 && c <= 1 && r >= 13 && r <= 14) return 'frog';
  return null;
};

const isKingZone = (r, c) => {
  // Duck zone: around duck king (cols 6-8, rows 0-2, excluding king)
  if (c >= 6 && c <= 8 && r >= 0 && r <= 2 && !isKingTile(r, c)) {
    if (c === 6 || r === 2) return 'duck';
  }
  // Frog zone: around frog king (cols 0-2, rows 12-14, excluding king)
  if (c >= 0 && c <= 2 && r >= 12 && r <= 14 && !isKingTile(r, c)) {
    if (c === 2 || r === 12) return 'frog';
  }
  return null;
};

// Diagonal: row = col + 3
const isDivider = (r, c) => r === c + 3;

const getTerritory = (r, c) => {
  // Above diagonal (r < c + 3) = duck territory (top-right)
  // Below diagonal (r > c + 3) = frog territory (bottom-left)
  if (r < c + 3) return 'duck';
  if (r > c + 3) return 'frog';
  return 'neutral'; // On the diagonal
};

const findObstacle = (r, c) => game.obstacles.find(o => o.row === r && o.col === c);
const findAlly = (r, c) => game.allies.find(a => a.row === r && a.col === c);
const findPlayer = (r, c) => {
  if (game.players.duck.row === r && game.players.duck.col === c) return 'duck';
  if (game.players.frog.row === r && game.players.frog.col === c) return 'frog';
  return null;
};
const findTotem = (r, c) => {
  for (let key in game.totems) {
    const t = game.totems[key];
    if (t.row === r && t.col === c && !t.pickedBy) return key;
  }
  return null;
};

const isTileBlocked = (r, c) => {
  if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true;
  if (isKingTile(r, c)) return true;
  if (findObstacle(r, c)) return true;
  if (findPlayer(r, c)) return true;
  if (findAlly(r, c)) return true;
  return false;
};

const distance = (r1, c1, r2, c2) => Math.abs(r1 - r2) + Math.abs(c1 - c2);

// ============ INIT ============
function initGame() {
  game.tick = 0;
  game.gameOver = false;
  game.gameStarted = false;
  game.humanPlayer = null;
  game.aiPlayer = null;
  
  // Reset players
  game.players.duck = { row: 0, col: 5, hp: 1, hasTotem: false, targetPath: [] };
  game.players.frog = { row: 14, col: 3, hp: 1, hasTotem: false, targetPath: [] };
  
  // Reset totems
  game.totems.snake = { row: 0, col: 0, owner: 'frog', pickedBy: null };
  game.totems.duck = { row: 14, col: 8, owner: 'duck', pickedBy: null };
  
  // Clear allies
  game.allies = [];
  game.allyPaths = {};
  
  // Generate obstacles
  game.obstacles = [];
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      if (isKingZone(r, c)) continue;
      if (isDivider(r, c)) continue; // Skip divider tiles
      
      // Don't place on player start positions
      if (r === 0 && c === 5) continue; // duck start
      if (r === 14 && c === 3) continue; // frog start
      
      // Don't place on totem positions
      if (r === 0 && c === 0) continue; // snake totem
      if (r === 14 && c === 8) continue; // duck totem
      
      if (Math.random() < OBSTACLE_DENSITY) {
        const territory = getTerritory(r, c);
        if (territory === 'duck') {
          game.obstacles.push({ row: r, col: c, type: 'wave' });
        } else if (territory === 'frog') {
          game.obstacles.push({ row: r, col: c, type: 'bush' });
        }
      }
    }
  }
  
  render();
  updateHUD();
}

// ============ RENDER ============
function render() {
  // Update ally paths for visualization
  updateAllyPaths();
  
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  
  // Kings first
  const duckKing = document.createElement('div');
  duckKing.className = 'tile king duck-king';
  duckKing.textContent = EMOJI.duckKing;
  boardEl.appendChild(duckKing);
  
  const frogKing = document.createElement('div');
  frogKing.className = 'tile king frog-king';
  frogKing.textContent = EMOJI.frogKing;
  boardEl.appendChild(frogKing);
  
  // All tiles
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.style.gridColumn = c + 1;
      tile.style.gridRow = r + 1;
      
      // Zone styling
      const zone = isKingZone(r, c);
      if (zone === 'duck') tile.classList.add('duck-zone');
      if (zone === 'frog') tile.classList.add('frog-zone');
      
      // Divider diagonal styling
      if (isDivider(r, c)) tile.classList.add('divider');
      
      // Check if tile is on ally path
      const getAllyPathType = () => {
        for (let i = 0; i < game.allies.length; i++) {
          const path = game.allyPaths[i];
          if (path && path.some(p => p.row === r && p.col === c)) {
            return game.allies[i].type;
          }
        }
        return null;
      };
      
      // Content
      let content = '';
      let extraClass = '';
      let badges = '';
      
      // Path visualization (before obstacles so it shows under them)
      const pathType = getAllyPathType();
      if (pathType && !findObstacle(r, c) && !findPlayer(r, c) && !findAlly(r, c)) {
        tile.classList.add(`ally-path-${pathType}`);
      }
      
      // Human player target path visualization
      if (game.humanPlayer) {
        const humanPath = game.players[game.humanPlayer].targetPath;
        if (humanPath && humanPath.some(p => p.row === r && p.col === c)) {
          tile.classList.add('player-path');
        }
      }
      
      // Obstacles
      const obstacle = findObstacle(r, c);
      if (obstacle) {
        content = obstacle.type === 'wave' ? EMOJI.wave : EMOJI.bush;
        extraClass = 'obstacle';
      }
      
      // Totems
      const totemKey = findTotem(r, c);
      if (totemKey) {
        content = totemKey === 'snake' ? EMOJI.snakeTotem : EMOJI.duckTotem;
        extraClass = 'totem';
      }
      
      // Allies
      const ally = findAlly(r, c);
      if (ally) {
        content = ally.type === 'duck' ? EMOJI.duckAlly : EMOJI.frogAlly;
        extraClass = 'ally';
      }
      
      // Players - don't render in tiles, use sprites instead
      // Just mark the tile
      const playerType = findPlayer(r, c);
      if (playerType) {
        extraClass = 'player';
      }
      
      tile.innerHTML = content + badges;
      if (extraClass) tile.classList.add(extraClass);
      
      // Click handler
      tile.onclick = () => handleTileClick(r, c);
      
      boardEl.appendChild(tile);
    }
  }
  
  // Update player sprite positions
  updatePlayerSprites();
}

// Update animated player sprites
function updatePlayerSprites() {
  const boardEl = document.getElementById('board');
  const boardRect = boardEl.getBoundingClientRect();
  const padding = 8;
  const gap = 3;
  
  const cellWidth = (boardRect.width - padding * 2 - gap * 8) / 9;
  const cellHeight = (boardRect.height - padding * 2 - gap * 14) / 15;
  
  // Duck sprite
  const duck = game.players.duck;
  const duckSprite = document.getElementById('duckSprite');
  duckSprite.style.width = cellWidth + 'px';
  duckSprite.style.height = cellHeight + 'px';
  duckSprite.style.fontSize = (cellHeight * 0.6) + 'px';
  duckSprite.style.left = (padding + duck.col * (cellWidth + gap)) + 'px';
  duckSprite.style.top = (padding + duck.row * (cellHeight + gap)) + 'px';
  document.getElementById('duckSpriteBadge').textContent = duck.hp;
  
  // Update totem indicator
  let duckTotem = duckSprite.querySelector('.totem-indicator');
  if (duck.hasTotem) {
    if (!duckTotem) {
      duckTotem = document.createElement('span');
      duckTotem.className = 'totem-indicator';
      duckSprite.appendChild(duckTotem);
    }
    duckTotem.textContent = EMOJI.duckTotem;
  } else if (duckTotem) {
    duckTotem.remove();
  }
  
  // Frog sprite
  const frog = game.players.frog;
  const frogSprite = document.getElementById('frogSprite');
  frogSprite.style.width = cellWidth + 'px';
  frogSprite.style.height = cellHeight + 'px';
  frogSprite.style.fontSize = (cellHeight * 0.6) + 'px';
  frogSprite.style.left = (padding + frog.col * (cellWidth + gap)) + 'px';
  frogSprite.style.top = (padding + frog.row * (cellHeight + gap)) + 'px';
  document.getElementById('frogSpriteBadge').textContent = frog.hp;
  
  // Update totem indicator
  let frogTotem = frogSprite.querySelector('.totem-indicator');
  if (frog.hasTotem) {
    if (!frogTotem) {
      frogTotem = document.createElement('span');
      frogTotem.className = 'totem-indicator';
      frogSprite.appendChild(frogTotem);
    }
    frogTotem.textContent = EMOJI.snakeTotem;
  } else if (frogTotem) {
    frogTotem.remove();
  }
}

function updateHUD() {
  document.getElementById('duckHp').textContent = `‚ù§Ô∏è ${game.players.duck.hp}`;
  document.getElementById('frogHp').textContent = `‚ù§Ô∏è ${game.players.frog.hp}`;
  document.getElementById('duckTotem').textContent = game.players.duck.hasTotem ? 'ü¶Ü' : '';
  document.getElementById('frogTotem').textContent = game.players.frog.hasTotem ? 'üêç' : '';
  
  let turnText = `–¢—ñ–∫: ${game.tick}`;
  if (game.humanPlayer) {
    const emoji = game.humanPlayer === 'duck' ? 'üê§' : 'üê∏';
    turnText += ` | –¢–∏ –≥—Ä–∞—î—à –∑–∞ ${emoji}`;
  }
  document.getElementById('turnInfo').textContent = turnText;
}

// ============ GAME LOGIC ============
function handleTileClick(r, c) {
  if (game.gameOver || !game.gameStarted) return;
  if (!game.humanPlayer) return;
  
  const player = game.players[game.humanPlayer];
  
  // Can't click on kings
  if (isKingTile(r, c)) return;
  
  // Can't click on same tile
  if (player.row === r && player.col === c) return;
  
  const dist = distance(player.row, player.col, r, c);
  
  // If clicking on adjacent tile (distance 1), do immediate action
  if (dist === 1) {
    const obstacle = findObstacle(r, c);
    const enemyType = findPlayer(r, c);
    const ally = findAlly(r, c);
    
    // Attack enemy player immediately
    if (enemyType && enemyType !== game.humanPlayer) {
      combat(game.humanPlayer, enemyType);
      render();
      updateHUD();
      return;
    }
    
    // Attack enemy ally immediately
    if (ally && ally.type !== game.humanPlayer) {
      if (player.hp > 1) {
        player.hp--;
        const allyTile = document.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`);
        if (allyTile) allyTile.classList.add('breaking');
        updateHUD();
        updatePlayerSprites();
        setTimeout(() => {
          game.allies = game.allies.filter(a => a !== ally);
          render();
        }, 250);
      } else {
        // Show can't attack feedback
        const allyTile = document.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`);
        if (allyTile) {
          allyTile.classList.add('cant-break');
          setTimeout(() => allyTile.classList.remove('cant-break'), 300);
        }
      }
      return;
    }
    
    // Break obstacle immediately
    if (obstacle) {
      if (player.hp > 1) {
        player.hp--;
        const obstacleTile = document.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`);
        if (obstacleTile) obstacleTile.classList.add('breaking');
        updateHUD();
        updatePlayerSprites();
        setTimeout(() => {
          game.obstacles = game.obstacles.filter(o => o !== obstacle);
          render();
        }, 250);
      } else {
        // Show can't break feedback
        const obstacleTile = document.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`);
        if (obstacleTile) {
          obstacleTile.classList.add('cant-break');
          setTimeout(() => obstacleTile.classList.remove('cant-break'), 300);
        }
      }
      return;
    }
    
    // Move to empty adjacent tile immediately
    if (!isTileBlocked(r, c)) {
      player.row = r;
      player.col = c;
      player.targetPath = []; // Clear any existing path
      
      // Pick up totem
      const totemKey = findTotem(r, c);
      if (totemKey) {
        const totem = game.totems[totemKey];
        if (totem.owner === game.humanPlayer && !totem.pickedBy) {
          totem.pickedBy = game.humanPlayer;
          player.hasTotem = true;
          totem.row = -1;
          totem.col = -1;
        }
      }
      
      // Check win
      if (player.hasTotem) {
        const zone = isKingZone(r, c);
        if (zone === game.humanPlayer) {
          gameWin(game.humanPlayer);
          return;
        }
      }
      
      render();
      updateHUD();
      return;
    }
  }
  
  // For tiles further away, set path (can always change destination)
  // –°–ø–æ—á–∞—Ç–∫—É –ø—Ä–æ–±—É—î–º–æ –∑–Ω–∞–π—Ç–∏ —à–ª—è—Ö –¥–æ —Ü—ñ–ª—å–æ–≤–æ—ó –∫–ª—ñ—Ç–∏–Ω–∫–∏
  let path = findPath(player.row, player.col, r, c);

  // –Ø–∫—â–æ —Ü—ñ–ª—å –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–∞ (–ø–µ—Ä–µ—à–∫–æ–¥–∞/–≤–æ—Ä–æ–≥), —à—É–∫–∞—î–º–æ —à–ª—è—Ö –¥–æ —Å—É—Å—ñ–¥–Ω—å–æ—ó –∫–ª—ñ—Ç–∏–Ω–∫–∏
  if (!path && (findObstacle(r, c) || findPlayer(r, c) || findAlly(r, c))) {
    // –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π–±–ª–∏–∂—á—É –≤—ñ–ª—å–Ω—É –∫–ª—ñ—Ç–∏–Ω–∫—É –ø–æ—Ä—É—á –∑ —Ü—ñ–ª–ª—é
    const directions = [{dr: -1, dc: 0}, {dr: 1, dc: 0}, {dr: 0, dc: -1}, {dr: 0, dc: 1}];
    let bestPath = null;
    for (const dir of directions) {
      const nr = r + dir.dr;
      const nc = c + dir.dc;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      const testPath = findPath(player.row, player.col, nr, nc);
      if (testPath && (!bestPath || testPath.length < bestPath.length)) {
        bestPath = testPath;
      }
    }
    if (bestPath) {
      // –î–æ–¥–∞—î–º–æ —Ü—ñ–ª—å–æ–≤—É –∫–ª—ñ—Ç–∏–Ω–∫—É –≤ –∫—ñ–Ω–µ—Ü—å —à–ª—è—Ö—É (–¥–ª—è –∞—Ç–∞–∫–∏/–ª–∞–º–∞–Ω–Ω—è)
      path = [...bestPath, {row: r, col: c}];
    }
  }

  if (path && path.length > 0 && path.length <= 3) {
    player.targetPath = path;
    render();
  }
}

function combat(attackerType, defenderType) {
  const attacker = game.players[attackerType];
  const defender = game.players[defenderType];
  
  let winner, loser;
  
  if (attacker.hp > defender.hp) {
    winner = attacker;
    loser = defender;
  } else if (defender.hp > attacker.hp) {
    winner = defender;
    loser = attacker;
  } else {
    // Random winner if equal
    if (Math.random() < 0.5) {
      winner = attacker;
      loser = defender;
    } else {
      winner = defender;
      loser = attacker;
    }
  }
  
  const loserType = loser === game.players.duck ? 'duck' : 'frog';
  
  // Winner loses HP equal to loser's HP (min 1)
  winner.hp = Math.max(1, winner.hp - loser.hp);
  
  // Loser drops totem if carrying
  if (loser.hasTotem) {
    const totemKey = loserType === 'duck' ? 'duck' : 'snake';
    game.totems[totemKey].row = loser.row;
    game.totems[totemKey].col = loser.col;
    game.totems[totemKey].pickedBy = null;
    loser.hasTotem = false;
  }
  
  // Loser respawns
  if (loserType === 'duck') {
    loser.row = 0;
    loser.col = 5;
  } else {
    loser.row = 14;
    loser.col = 3;
  }
  loser.hp = 1;
  loser.targetPath = []; // Clear path on death
}

function spawnAlly(type) {
  // Find empty tile near king
  const kingZoneTiles = [];
  
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === type && !isTileBlocked(r, c)) {
        kingZoneTiles.push({ r, c });
      }
    }
  }
  
  if (kingZoneTiles.length > 0) {
    const pos = kingZoneTiles[Math.floor(Math.random() * kingZoneTiles.length)];
    game.allies.push({ type, row: pos.r, col: pos.c });
  }
}

function updateAllyPaths() {
  game.allyPaths = {};
  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    if (ally.row < 0) continue;
    const player = game.players[ally.type];
    const path = findPath(ally.row, ally.col, player.row, player.col, false); // allies can't break obstacles
    if (path) {
      game.allyPaths[i] = path;
    }
  }
}

function moveAllies() {
  game.allyPaths = {}; // Clear paths
  
  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    const player = game.players[ally.type];
    
    // If reached player (adjacent), add HP
    if (distance(ally.row, ally.col, player.row, player.col) <= 1) {
      player.hp++;
      ally.row = -100; // Mark for removal
      continue;
    }
    
    // Use BFS to find optimal path - allies CAN'T break obstacles (false parameter)
    // If path is blocked by obstacles, ally won't move
    const path = findPath(ally.row, ally.col, player.row, player.col, false);
    if (path && path.length > 0) {
      // Check if next step is actually free (not blocked by other allies or obstacles)
      const nextStep = path[0];
      if (!findAlly(nextStep.row, nextStep.col) && !findObstacle(nextStep.row, nextStep.col)) {
        // Store path for visualization
        game.allyPaths[i] = path;
        // Move to next step
        ally.row = nextStep.row;
        ally.col = nextStep.col;
      }
    }
  }
  
  // Remove absorbed allies
  game.allies = game.allies.filter(a => a.row >= 0);
}

// BFS pathfinding - returns full path to target
// allowObstacles = true for player movement (they can break obstacles)
function findPath(fromR, fromC, toR, toC, allowObstacles = true) {
  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, path: [] }];
  visited.add(`${fromR},${fromC}`);
  
  const directions = [
    { dr: -1, dc: 0 },  // up
    { dr: 1, dc: 0 },   // down
    { dr: 0, dc: -1 },  // left
    { dr: 0, dc: 1 }    // right
  ];
  
  while (queue.length > 0) {
    const current = queue.shift();
    
    // Found target
    if (current.r === toR && current.c === toC) {
      return current.path;
    }
    
    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const key = `${nr},${nc}`;
      
      if (visited.has(key)) continue;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      // Allow obstacles if flag is set (player can break them)
      if (!allowObstacles && findObstacle(nr, nc)) continue;
      // Can't walk through players (except target)
      const playerOnTile = findPlayer(nr, nc);
      if (playerOnTile && !(nr === toR && nc === toC)) continue;
      
      visited.add(key);
      const newPath = [...current.path, { row: nr, col: nc }];
      queue.push({ r: nr, c: nc, path: newPath });
    }
  }
  
  return null; // No path found
}

// Get next step only (for compatibility)
function findNextStep(fromR, fromC, toR, toC) {
  const path = findPath(fromR, fromC, toR, toC);
  return path && path.length > 0 ? path[0] : null;
}

function gameWin(playerType) {
  game.gameOver = true;
  if (game.tickTimer) clearInterval(game.tickTimer);
  
  const emoji = playerType === 'duck' ? 'üê§' : 'üê∏';
  const name = playerType === 'duck' ? '–ö–∞—á–µ–Ω—è' : '–ñ–∞–±–∫–∞';
  const isHuman = playerType === game.humanPlayer;
  
  if (isHuman) {
    document.getElementById('winnerText').textContent = `üèÜ ${emoji} –ü–µ—Ä–µ–º–æ–≥–∞!`;
    document.getElementById('winnerDesc').textContent = `–¢–∏ –ø–µ—Ä–µ–º—ñ–≥! ${name} –¥–æ—Å—Ç–∞–≤–∏–≤ —Ç–æ—Ç–µ–º –∫–æ—Ä–æ–ª—é!`;
  } else {
    document.getElementById('winnerText').textContent = `üò¢ ${emoji} –ü—Ä–æ–≥—Ä–∞—à`;
    document.getElementById('winnerDesc').textContent = `AI –ø–µ—Ä–µ–º—ñ–≥. ${name} –¥–æ—Å—Ç–∞–≤–∏–≤ —Ç–æ—Ç–µ–º –∫–æ—Ä–æ–ª—é.`;
  }
  document.getElementById('winModal').classList.add('show');
}

function closeModal() {
  document.getElementById('winModal').classList.remove('show');
}

function resetGame() {
  closeModal();
  if (game.tickTimer) clearInterval(game.tickTimer);
  
  // Reset AI indicator
  document.querySelectorAll('.player-info').forEach(el => el.classList.remove('ai'));
  
  // Show character selection
  document.getElementById('selectModal').classList.add('show');
  
  initGame();
}

// ============ START ============
function selectCharacter(character) {
  game.humanPlayer = character;
  game.aiPlayer = character === 'duck' ? 'frog' : 'duck';
  game.gameStarted = true;
  
  // Update HUD to show AI indicator
  document.querySelector(`.player-info.${game.aiPlayer}`).classList.add('ai');
  
  // Close selection modal
  document.getElementById('selectModal').classList.remove('show');
  
  // Start the game tick
  startGameTick();
  
  render();
  updateHUD();
}

function startGameTick() {
  if (game.tickTimer) clearInterval(game.tickTimer);
  game.tickTimer = setInterval(() => {
    if (!game.gameOver && game.gameStarted) {
      gameTick();
    }
  }, TICK_MS);
}

function gameTick() {
  game.tick++;
  
  // Spawn allies every 4 ticks
  if (game.tick % ALLY_SPAWN_TICKS === 0) {
    spawnAlly('duck');
    spawnAlly('frog');
  }
  
  // Move allies
  moveAllies();
  
  // Move human player one step if has path
  if (game.humanPlayer) {
    movePlayerOneStep(game.humanPlayer);
  }
  
  // AI makes one step
  aiMove();
  
  render();
  updateHUD();
}

// Move player one step along their path
function movePlayerOneStep(playerType) {
  const player = game.players[playerType];
  
  if (!player.targetPath || player.targetPath.length === 0) return;
  
  const nextStep = player.targetPath[0];
  
  // Check what's on next step
  const obstacle = findObstacle(nextStep.row, nextStep.col);
  const enemyType = findPlayer(nextStep.row, nextStep.col);
  const ally = findAlly(nextStep.row, nextStep.col);
  
  // Attack enemy player
  if (enemyType && enemyType !== playerType) {
    combat(playerType, enemyType);
    player.targetPath = []; // Clear path after combat
    return;
  }
  
  // Attack enemy ally
  if (ally && ally.type !== playerType) {
    if (player.hp > 1) {
      player.hp--;
      // Add death animation to ally tile
      const allyTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (allyTile) {
        allyTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites();
      setTimeout(() => {
        game.allies = game.allies.filter(a => a !== ally);
        render();
      }, 250);
    } else {
      player.targetPath = []; // Can't proceed
    }
    return;
  }
  
  // Break obstacle
  if (obstacle) {
    if (player.hp > 1) {
      player.hp--;
      // Add breaking animation
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites(); // Update sprite HP badge
      // Remove obstacle after animation
      setTimeout(() => {
        game.obstacles = game.obstacles.filter(o => o !== obstacle);
        render();
      }, 250);
    } else {
      // Show can't break feedback
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('cant-break');
        setTimeout(() => obstacleTile.classList.remove('cant-break'), 300);
      }
      player.targetPath = []; // Can't proceed
    }
    return;
  }
  
  // Check if tile is blocked by something else
  if (isTileBlocked(nextStep.row, nextStep.col)) {
    player.targetPath = []; // Path blocked
    return;
  }
  
  // Move player
  player.row = nextStep.row;
  player.col = nextStep.col;
  player.targetPath.shift(); // Remove completed step
  
  // Pick up totem
  const totemKey = findTotem(player.row, player.col);
  if (totemKey) {
    const totem = game.totems[totemKey];
    if (totem.owner === playerType && !totem.pickedBy) {
      totem.pickedBy = playerType;
      player.hasTotem = true;
      totem.row = -1;
      totem.col = -1;
    }
  }
  
  // Check win condition
  if (player.hasTotem) {
    const zone = isKingZone(player.row, player.col);
    if (zone === playerType) {
      gameWin(playerType);
    }
  }
}

// ============ AI LOGIC ============
function aiMove() {
  if (!game.aiPlayer || game.gameOver) return;
  
  const ai = game.players[game.aiPlayer];
  const human = game.players[game.humanPlayer];
  
  // Determine AI goal
  let targetR, targetC;
  
  if (ai.hasTotem) {
    // Has totem - go to king zone
    const kingZone = findNearestKingZone(game.aiPlayer, ai.row, ai.col);
    if (kingZone) {
      targetR = kingZone.row;
      targetC = kingZone.col;
    }
  } else {
    // Need totem - go get it
    const totemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
    const totem = game.totems[totemKey];
    if (totem.pickedBy === null) {
      targetR = totem.row;
      targetC = totem.col;
    }
  }
  
  if (targetR === undefined) return;
  
  // Find path to target
  const path = findPathForAI(ai.row, ai.col, targetR, targetC);
  
  if (path && path.length > 0) {
    const nextStep = path[0];
    
    // Check what's on next step
    const obstacle = findObstacle(nextStep.row, nextStep.col);
    const enemyOnTile = findPlayer(nextStep.row, nextStep.col);
    const enemyAlly = findAlly(nextStep.row, nextStep.col);
    
    // Attack enemy player if in the way and we have advantage
    if (enemyOnTile && enemyOnTile !== game.aiPlayer) {
      if (ai.hp >= human.hp) {
        combat(game.aiPlayer, game.humanPlayer);
        return;
      }
    }
    
    // Kill enemy ally if in the way
    if (enemyAlly && enemyAlly.type !== game.aiPlayer) {
      if (ai.hp > 1) {
        ai.hp--;
        game.allies = game.allies.filter(a => a !== enemyAlly);
        return;
      }
    }
    
    // Break obstacle if in the way
    if (obstacle) {
      if (ai.hp > 1) {
        ai.hp--;
        game.obstacles = game.obstacles.filter(o => o !== obstacle);
        return;
      } else {
        // Can't break, try to find alternative path
        return;
      }
    }
    
    // Move
    if (!isTileBlocked(nextStep.row, nextStep.col)) {
      ai.row = nextStep.row;
      ai.col = nextStep.col;
      
      // Pick up totem
      const totemKey = findTotem(ai.row, ai.col);
      if (totemKey) {
        const totem = game.totems[totemKey];
        if (totem.owner === game.aiPlayer && !totem.pickedBy) {
          totem.pickedBy = game.aiPlayer;
          ai.hasTotem = true;
          totem.row = -1;
          totem.col = -1;
        }
      }
      
      // Check win
      if (ai.hasTotem) {
        const zone = isKingZone(ai.row, ai.col);
        if (zone === game.aiPlayer) {
          gameWin(game.aiPlayer);
        }
      }
    }
  }
}

function findNearestKingZone(playerType, fromR, fromC) {
  let nearest = null;
  let minDist = Infinity;
  
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === playerType && !isTileBlocked(r, c)) {
        const d = distance(fromR, fromC, r, c);
        if (d < minDist) {
          minDist = d;
          nearest = { row: r, col: c };
        }
      }
    }
  }
  
  return nearest;
}

function findPathForAI(fromR, fromC, toR, toC) {
  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, path: [] }];
  visited.add(`${fromR},${fromC}`);
  
  const directions = [
    { dr: -1, dc: 0 },
    { dr: 1, dc: 0 },
    { dr: 0, dc: -1 },
    { dr: 0, dc: 1 }
  ];
  
  while (queue.length > 0) {
    const current = queue.shift();
    
    if (current.r === toR && current.c === toC) {
      return current.path;
    }
    
    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const key = `${nr},${nc}`;
      
      if (visited.has(key)) continue;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      
      visited.add(key);
      const newPath = [...current.path, { row: nr, col: nc }];
      queue.push({ r: nr, c: nc, path: newPath });
    }
  }
  
  return null;
}

initGame();

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (game.tickTimer) clearInterval(game.tickTimer);
});
</script>
</body>
</html>
