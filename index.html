<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>üê§ vs üê∏</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #e0e5ec;
      --shadow-d: #a3b1c6;
      --shadow-l: #ffffff;
      --duck-color: rgba(247, 220, 111, 0.4);
      --frog-color: rgba(139, 195, 74, 0.4);
      --divider-color: rgba(120, 130, 150, 0.3);
    }
    html, body { 
      height: 100%; 
      overflow: hidden;
      touch-action: manipulation;
    }
    body {
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', system-ui, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 10px;
    }

    /* HUD */
    .hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 320px;
      margin-bottom: 10px;
      gap: 10px;
    }
    .player-info {
      flex: 1;
      padding: 10px 15px;
      border-radius: 16px;
      background: var(--bg);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .player-info.duck { border: 2px solid var(--duck-color); }
    .player-info.frog { border: 2px solid var(--frog-color); }
    .player-icon { font-size: 1.5rem; }
    .player-hp {
      font-size: 1.2rem;
      font-weight: 700;
      color: #e74c3c;
    }
    .player-totem {
      font-size: 0.9rem;
      opacity: 0.7;
    }

    /* Board */
    .board-container {
      position: relative;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(15, 1fr);
      gap: 3px;
      width: min(calc(100vw - 20px), 300px);
      aspect-ratio: 9 / 15;
      padding: 8px;
      border-radius: 16px;
      background: var(--bg);
      box-shadow: 
        8px 8px 16px var(--shadow-d),
        -8px -8px 16px var(--shadow-l);
    }

    /* Tiles */
    .tile {
      border-radius: 6px;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      cursor: pointer;
      position: relative;
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l);
      transition: transform 0.1s, box-shadow 0.1s;
      border: 2px solid transparent;
    }
    .tile:active {
      transform: scale(0.95);
      box-shadow: 
        inset 2px 2px 4px var(--shadow-d),
        inset -2px -2px 4px var(--shadow-l);
    }
    
    /* Divider diagonal - tiles on the diagonal line */
    .tile.divider {
      border: 2px solid rgba(120, 130, 150, 0.5);
    }

    /* King zones */
    .tile.duck-zone {
      border-color: var(--duck-color);
    }
    .tile.frog-zone {
      border-color: var(--frog-color);
    }

    /* Kings */
    .tile.king {
      grid-column: span 2;
      grid-row: span 2;
      font-size: 2rem;
      cursor: default;
      border-radius: 10px;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .tile.duck-king {
      grid-column: 8 / 10;
      grid-row: 1 / 3;
      border: 3px solid var(--duck-color);
    }
    .tile.frog-king {
      grid-column: 1 / 3;
      grid-row: 14 / 16;
      border: 3px solid var(--frog-color);
    }

    /* Game objects */
    .tile.obstacle {
      background: rgba(200, 200, 200, 0.5);
    }
    .tile.obstacle.breaking {
      animation: obstacle-break 0.3s ease-out;
    }
    @keyframes obstacle-break {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    .tile.obstacle.cant-break {
      animation: obstacle-shake 0.3s ease-out;
    }
    @keyframes obstacle-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }
    
    .tile.player {
      z-index: 10;
      box-shadow: 
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    
    /* Animated player sprites */
    .player-sprite {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: var(--bg);
      z-index: 20;
      pointer-events: none;
      transition: left 0.3s ease-out, top 0.3s ease-out;
      box-shadow: 
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    .player-sprite .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .player-sprite .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 0.6rem;
      background: white;
      border-radius: 50%;
      padding: 2px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    
    .tile.ally {
      font-size: 0.7rem;
      opacity: 0.8;
    }
    .tile.ally.breaking {
      animation: obstacle-break 0.3s ease-out;
    }
    
    /* Path visualization for allies */
    .tile.ally-path-duck::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(247, 220, 111, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    .tile.ally-path-frog::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(139, 195, 74, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    
    /* Player target path visualization */
    .tile.player-path {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        inset 0 0 8px rgba(100, 150, 255, 0.4);
    }
    .tile.totem {
      animation: totem-glow 2s ease-in-out infinite;
    }
    @keyframes totem-glow {
      0%, 100% { box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l); }
      50% { box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l), 0 0 10px rgba(255, 215, 0, 0.5); }
    }

    /* Highlight for valid moves */
    .tile.highlight {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        0 0 0 3px rgba(100, 200, 100, 0.5);
    }

    /* Totem indicator on player */
    .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 0.6rem;
      background: white;
      border-radius: 50%;
      padding: 2px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    /* HP badge on player */
    .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    /* Controls */
    .controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: #333;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .btn:active {
      box-shadow: 
        inset 3px 3px 6px var(--shadow-d),
        inset -3px -3px 6px var(--shadow-l);
    }

    /* Turn indicator */
    .turn-info {
      margin-top: 10px;
      font-size: 0.8rem;
      color: #666;
      text-align: center;
    }

    /* Winner modal */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: var(--bg);
      padding: 30px 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 
        10px 10px 20px var(--shadow-d),
        -10px -10px 20px var(--shadow-l);
    }
    .modal-content h2 {
      font-size: 2rem;
      margin-bottom: 10px;
    }
    .modal-content p {
      font-size: 1rem;
      color: #666;
      margin-bottom: 20px;
    }
    
    /* Character selection */
    .select-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
    }
    .select-btn {
      padding: 20px 30px;
      border: none;
      border-radius: 16px;
      background: var(--bg);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      transition: all 0.2s;
    }
    .select-btn:hover {
      transform: scale(1.05);
    }
    .select-btn:active {
      box-shadow: 
        inset 4px 4px 8px var(--shadow-d),
        inset -4px -4px 8px var(--shadow-l);
    }
    .select-btn.duck-select:hover {
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--duck-color);
    }
    .select-btn.frog-select:hover {
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--frog-color);
    }
    .select-icon {
      font-size: 3rem;
    }
    .select-name {
      font-size: 1rem;
      font-weight: 600;
      color: #333;
    }
    
    /* AI indicator */
    .player-info.ai::after {
      content: 'ü§ñ';
      margin-left: 5px;
    }

    /* ============ SCREENS ============ */
    .screen {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--bg);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 50;
    }
    .screen.active { display: flex; }

    /* Main Menu */
    .menu-title {
      font-size: 3rem;
      margin-bottom: 10px;
    }
    .menu-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin-bottom: 40px;
    }
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 100%;
      max-width: 250px;
    }
    .menu-btn {
      padding: 18px 30px;
      border: none;
      border-radius: 16px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: #333;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      transition: all 0.2s;
    }
    .menu-btn:active {
      box-shadow:
        inset 4px 4px 8px var(--shadow-d),
        inset -4px -4px 8px var(--shadow-l);
    }
    .menu-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    /* Settings Screen */
    .settings-container {
      width: 100%;
      max-width: 320px;
    }
    .settings-title {
      font-size: 1.5rem;
      margin-bottom: 25px;
      text-align: center;
    }
    .setting-item {
      background: var(--bg);
      padding: 15px 20px;
      border-radius: 12px;
      margin-bottom: 15px;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .setting-label {
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 0;
    }
    .setting-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .toggle-switch {
      width: 50px;
      height: 28px;
      background: var(--shadow-d);
      border-radius: 14px;
      position: relative;
      cursor: pointer;
      transition: background 0.3s;
    }
    .toggle-switch.on {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: left 0.3s;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }
    .toggle-switch.on::after {
      left: 25px;
    }
    .back-btn {
      margin-top: 25px;
      padding: 12px 30px;
    }

    /* Tutorial Screen */
    .tutorial-container {
      width: 100%;
      max-width: 320px;
      text-align: center;
    }
    .tutorial-title {
      font-size: 1.5rem;
      margin-bottom: 20px;
    }
    .tutorial-slide {
      display: none;
      background: var(--bg);
      padding: 25px;
      border-radius: 16px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      min-height: 250px;
    }
    .tutorial-slide.active { display: block; }
    .tutorial-slide h3 {
      font-size: 1.2rem;
      margin-bottom: 15px;
    }
    .tutorial-slide p {
      font-size: 0.95rem;
      color: #555;
      line-height: 1.5;
    }
    .tutorial-slide .emoji-big {
      font-size: 3rem;
      margin-bottom: 15px;
    }
    .tutorial-nav {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }
    .tutorial-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--shadow-d);
      cursor: pointer;
    }
    .tutorial-dot.active {
      background: #667eea;
    }
    .tutorial-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      justify-content: center;
    }

    /* Game Screen - —Ç—ñ–ª—å–∫–∏ –ø–æ–ª–µ —ñ —ñ–Ω—Ñ–æ –≤–Ω–∏–∑—É */
    #gameScreen {
      padding: 10px;
      justify-content: space-between;
    }
    .game-top {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .game-bottom {
      width: 100%;
      max-width: 320px;
    }
    .game-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: var(--bg);
      border-radius: 12px;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .game-info-left {
      font-size: 0.85rem;
      color: #666;
    }
    .game-info-right {
      display: flex;
      gap: 8px;
    }
    .game-btn-small {
      padding: 8px 12px;
      border: none;
      border-radius: 8px;
      font-size: 0.8rem;
      cursor: pointer;
      background: var(--bg);
      box-shadow:
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l);
    }
    .game-btn-small:active {
      box-shadow:
        inset 2px 2px 4px var(--shadow-d),
        inset -2px -2px 4px var(--shadow-l);
    }

    /* Character Select Modal - –æ–Ω–æ–≤–ª–µ–Ω–∏–π */
    .char-select-title {
      font-size: 1.3rem;
      margin-bottom: 20px;
    }

    /* Tick Progress Bar */
    .tick-progress-container {
      width: 100%;
      height: 6px;
      background: var(--shadow-d);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 8px;
    }
    .tick-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      border-radius: 3px;
      transition: width 0.05s linear;
    }
    .tick-progress-bar.reset {
      transition: none;
    }
  </style>
</head>
<body>

<!-- ============ MAIN MENU SCREEN ============ -->
<div class="screen active" id="menuScreen">
  <div class="menu-title">üê§ vs üê∏</div>
  <div class="menu-subtitle">–ö–∞—á–∫–∞ –ø—Ä–æ—Ç–∏ –ñ–∞–±–∫–∏</div>
  <div class="menu-buttons">
    <button class="menu-btn primary" onclick="showScreen('selectScreen')">‚ñ∂Ô∏è –ì—Ä–∞—Ç–∏</button>
    <button class="menu-btn" onclick="showScreen('settingsScreen')">‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</button>
    <button class="menu-btn" onclick="showScreen('tutorialScreen')">üìñ –Ø–∫ –≥—Ä–∞—Ç–∏</button>
  </div>
</div>

<!-- ============ CHARACTER SELECT SCREEN ============ -->
<div class="screen" id="selectScreen">
  <h2 class="char-select-title">üéÆ –û–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
  <div class="select-buttons">
    <button class="select-btn duck-select" onclick="selectCharacter('duck')">
      <span class="select-icon">üê§</span>
      <span class="select-name">–ö–∞—á–µ–Ω—è</span>
    </button>
    <button class="select-btn frog-select" onclick="selectCharacter('frog')">
      <span class="select-icon">üê∏</span>
      <span class="select-name">–ñ–∞–±–∫–∞</span>
    </button>
  </div>
  <button class="btn back-btn" onclick="showScreen('menuScreen')">‚Üê –ù–∞–∑–∞–¥</button>
</div>

<!-- ============ SETTINGS SCREEN ============ -->
<div class="screen" id="settingsScreen">
  <div class="settings-container">
    <h2 class="settings-title">‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</h2>

    <div class="setting-item setting-toggle">
      <div class="setting-label">–í—ñ–±—Ä–∞—Ü—ñ—è</div>
      <div class="toggle-switch on" id="vibrationToggle" onclick="toggleVibration()"></div>
    </div>

    <div class="setting-item setting-toggle">
      <div class="setting-label">–ó–≤—É–∫–∏</div>
      <div class="toggle-switch" id="soundToggle" onclick="toggleSound()"></div>
    </div>

    <button class="btn back-btn" onclick="showScreen('menuScreen')">‚Üê –ù–∞–∑–∞–¥</button>
  </div>
</div>

<!-- ============ TUTORIAL SCREEN ============ -->
<div class="screen" id="tutorialScreen">
  <div class="tutorial-container">
    <h2 class="tutorial-title">üìñ –Ø–∫ –≥—Ä–∞—Ç–∏</h2>

    <div class="tutorial-slide active" data-slide="0">
      <div class="emoji-big">üéØ</div>
      <h3>–ú–µ—Ç–∞ –≥—Ä–∏</h3>
      <p>–ó–∞–±–µ—Ä–∏ —Å–≤—ñ–π —Ç–æ—Ç–µ–º –∑ –≤–æ—Ä–æ–∂–æ—ó —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—ó —Ç–∞ –¥–æ–Ω–µ—Å–∏ –π–æ–≥–æ –¥–æ —Å–≤–æ–≥–æ –ö–æ—Ä–æ–ª—è!</p>
    </div>

    <div class="tutorial-slide" data-slide="1">
      <div class="emoji-big">üëÜ</div>
      <h3>–ö–µ—Ä—É–≤–∞–Ω–Ω—è</h3>
      <p>–ö–ª—ñ–∫–Ω–∏ –Ω–∞ –∫–ª—ñ—Ç–∏–Ω–∫—É —â–æ–± —Ä—É—Ö–∞—Ç–∏—Å—å. –ö–ª—ñ–∫–Ω–∏ –Ω–∞ –≤–æ—Ä–æ–≥–∞ —â–æ–± –∞—Ç–∞–∫—É–≤–∞—Ç–∏. –ö–ª—ñ–∫–Ω–∏ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É —â–æ–± –∑–ª–∞–º–∞—Ç–∏.</p>
    </div>

    <div class="tutorial-slide" data-slide="2">
      <div class="emoji-big">‚ù§Ô∏è</div>
      <h3>HP —Å–∏—Å—Ç–µ–º–∞</h3>
      <p>–°–æ—é–∑–Ω–∏–∫–∏ üê£ –ø—Ä–∏–Ω–æ—Å—è—Ç—å +1 HP. –õ–∞–º–∞–Ω–Ω—è –ø–µ—Ä–µ—à–∫–æ–¥ –∫–æ—à—Ç—É—î -1 HP. –í –±–æ—é –ø–µ—Ä–µ–º–∞–≥–∞—î —Ç–æ–π, —É –∫–æ–≥–æ –±—ñ–ª—å—à–µ HP!</p>
    </div>

    <div class="tutorial-slide" data-slide="3">
      <div class="emoji-big">üèÜ</div>
      <h3>–ü–µ—Ä–µ–º–æ–≥–∞</h3>
      <p>–ü—ñ–¥–±–µ—Ä–∏ —Å–≤—ñ–π —Ç–æ—Ç–µ–º —ñ –∑–∞–Ω–µ—Å–∏ –π–æ–≥–æ –≤ –∑–æ–Ω—É –±—ñ–ª—è —Å–≤–æ–≥–æ –ö–æ—Ä–æ–ª—è. –ê–ª–µ –±–µ—Ä–µ–∂–∏—Å—å –≤–æ—Ä–æ–≥–∞!</p>
    </div>

    <div class="tutorial-nav">
      <div class="tutorial-dot active" onclick="goToSlide(0)"></div>
      <div class="tutorial-dot" onclick="goToSlide(1)"></div>
      <div class="tutorial-dot" onclick="goToSlide(2)"></div>
      <div class="tutorial-dot" onclick="goToSlide(3)"></div>
    </div>

    <div class="tutorial-buttons">
      <button class="btn" id="tutorialPrev" onclick="prevSlide()" style="visibility: hidden;">‚Üê –ù–∞–∑–∞–¥</button>
      <button class="btn" id="tutorialNext" onclick="nextSlide()">–î–∞–ª—ñ ‚Üí</button>
    </div>
  </div>
</div>

<!-- ============ GAME SCREEN ============ -->
<div class="screen" id="gameScreen">
  <div class="game-top">
    <div class="board-container">
      <div class="board" id="board"></div>
      <div class="player-sprite" id="duckSprite">üê•<span class="hp-badge" id="duckSpriteBadge">1</span></div>
      <div class="player-sprite" id="frogSprite">üê∏<span class="hp-badge" id="frogSpriteBadge">1</span></div>
    </div>
  </div>

  <div class="game-bottom">
    <div class="game-info">
      <div class="game-info-left">
        <span>üê§ <span id="duckHp">‚ù§Ô∏è1</span></span>
        <span id="duckTotem"></span>
        <span style="margin: 0 8px;">|</span>
        <span>üê∏ <span id="frogHp">‚ù§Ô∏è1</span></span>
        <span id="frogTotem"></span>
      </div>
      <div class="game-info-right">
        <span id="turnInfo">–¢—ñ–∫: 0</span>
        <button class="game-btn-small" onclick="pauseGame()">‚è∏Ô∏è</button>
        <button class="game-btn-small" onclick="goToMenu()">üè†</button>
      </div>
    </div>
    <div class="tick-progress-container">
      <div class="tick-progress-bar" id="tickProgress"></div>
    </div>
  </div>
</div>

<!-- Winner Modal -->
<div class="modal" id="winModal">
  <div class="modal-content">
    <h2 id="winnerText">üèÜ</h2>
    <p id="winnerDesc">–ü–µ—Ä–µ–º—ñ–≥!</p>
    <button class="btn" onclick="goToMenu()">üè† –í –º–µ–Ω—é</button>
  </div>
</div>

<!-- Pause Modal -->
<div class="modal" id="pauseModal">
  <div class="modal-content">
    <h2>‚è∏Ô∏è –ü–∞—É–∑–∞</h2>
    <p>–ì—Ä–∞ –Ω–∞ –ø–∞—É–∑—ñ</p>
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <button class="btn" onclick="resumeGame()">‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏</button>
      <button class="btn" onclick="goToMenu()">üè† –í –º–µ–Ω—é</button>
    </div>
  </div>
</div>

<script>
// ============ CONSTANTS ============
const COLS = 9, ROWS = 15;
const TICK_MS = 1000; // 1 second per tick
const ALLY_SPAWN_TICKS = 6; // 6 sec / 1 sec = 6 ticks
const OBSTACLE_DENSITY = 0.3; // 30% chance per valid tile

// Diagonal divider from (col 0, row 3) to (col 8, row 11) in 0-indexed
// In 1-indexed: (1, 4) to (9, 12)

// Emoji
const EMOJI = {
  duckKing: 'üê§',
  frogKing: 'üê∏',
  duckPlayer: 'üê•',
  frogPlayer: 'üê∏',
  duckAlly: 'üê£',
  frogAlly: 'üê∏',
  snakeTotem: 'üêç',
  duckTotem: 'ü¶Ü',
  wave: 'üåä',
  bush: 'üåø'
};

// ============ GAME STATE ============
let game = {
  tick: 0,
  tickTimer: null,
  
  humanPlayer: null, // 'duck' or 'frog'
  aiPlayer: null,    // opposite of humanPlayer
  
  players: {
    duck: { row: 0, col: 5, hp: 1, hasTotem: false, targetPath: [] },
    frog: { row: 14, col: 3, hp: 1, hasTotem: false, targetPath: [] }
  },
  
  totems: {
    snake: { row: 0, col: 0, owner: 'frog', pickedBy: null },
    duck: { row: 14, col: 8, owner: 'duck', pickedBy: null }
  },
  
  allies: [],
  allyPaths: {}, // Store paths for visualization
  obstacles: [],

  gameOver: false,
  gameStarted: false,

  // Tick progress animation
  tickProgressTimer: null,
  tickStartTime: 0
};

// ============ HELPERS ============
const isKingTile = (r, c) => {
  // Duck king: cols 7-8, rows 0-1
  if (c >= 7 && c <= 8 && r >= 0 && r <= 1) return 'duck';
  // Frog king: cols 0-1, rows 13-14
  if (c >= 0 && c <= 1 && r >= 13 && r <= 14) return 'frog';
  return null;
};

const isKingZone = (r, c) => {
  // Duck zone: around duck king (cols 6-8, rows 0-2, excluding king)
  if (c >= 6 && c <= 8 && r >= 0 && r <= 2 && !isKingTile(r, c)) {
    if (c === 6 || r === 2) return 'duck';
  }
  // Frog zone: around frog king (cols 0-2, rows 12-14, excluding king)
  if (c >= 0 && c <= 2 && r >= 12 && r <= 14 && !isKingTile(r, c)) {
    if (c === 2 || r === 12) return 'frog';
  }
  return null;
};

// Diagonal: row = col + 3
const isDivider = (r, c) => r === c + 3;

const getTerritory = (r, c) => {
  // Above diagonal (r < c + 3) = duck territory (top-right)
  // Below diagonal (r > c + 3) = frog territory (bottom-left)
  if (r < c + 3) return 'duck';
  if (r > c + 3) return 'frog';
  return 'neutral'; // On the diagonal
};

const findObstacle = (r, c) => game.obstacles.find(o => o.row === r && o.col === c);
const findAlly = (r, c) => game.allies.find(a => a.row === r && a.col === c);
const findPlayer = (r, c) => {
  if (game.players.duck.row === r && game.players.duck.col === c) return 'duck';
  if (game.players.frog.row === r && game.players.frog.col === c) return 'frog';
  return null;
};
const findTotem = (r, c) => {
  for (let key in game.totems) {
    const t = game.totems[key];
    if (t.row === r && t.col === c && !t.pickedBy) return key;
  }
  return null;
};

const isTileBlocked = (r, c) => {
  if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true;
  if (isKingTile(r, c)) return true;
  if (findObstacle(r, c)) return true;
  if (findPlayer(r, c)) return true;
  if (findAlly(r, c)) return true;
  return false;
};

const distance = (r1, c1, r2, c2) => Math.abs(r1 - r2) + Math.abs(c1 - c2);

// ============ INIT ============
function initGame() {
  game.tick = 0;
  game.gameOver = false;
  game.gameStarted = false;
  game.humanPlayer = null;
  game.aiPlayer = null;
  
  // Reset players
  game.players.duck = { row: 0, col: 5, hp: 1, hasTotem: false, targetPath: [] };
  game.players.frog = { row: 14, col: 3, hp: 1, hasTotem: false, targetPath: [] };
  
  // Reset totems
  game.totems.snake = { row: 0, col: 0, owner: 'frog', pickedBy: null };
  game.totems.duck = { row: 14, col: 8, owner: 'duck', pickedBy: null };
  
  // Clear allies
  game.allies = [];
  game.allyPaths = {};
  
  // Generate obstacles
  game.obstacles = [];
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      if (isKingZone(r, c)) continue;
      if (isDivider(r, c)) continue; // Skip divider tiles
      
      // Don't place on player start positions
      if (r === 0 && c === 5) continue; // duck start
      if (r === 14 && c === 3) continue; // frog start
      
      // Don't place on totem positions
      if (r === 0 && c === 0) continue; // snake totem
      if (r === 14 && c === 8) continue; // duck totem
      
      if (Math.random() < OBSTACLE_DENSITY) {
        const territory = getTerritory(r, c);
        if (territory === 'duck') {
          game.obstacles.push({ row: r, col: c, type: 'wave' });
        } else if (territory === 'frog') {
          game.obstacles.push({ row: r, col: c, type: 'bush' });
        }
      }
    }
  }
  
  render();
  updateHUD();
}

// ============ RENDER ============
function render() {
  // Update ally paths for visualization
  updateAllyPaths();
  
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  
  // Kings first
  const duckKing = document.createElement('div');
  duckKing.className = 'tile king duck-king';
  duckKing.textContent = EMOJI.duckKing;
  boardEl.appendChild(duckKing);
  
  const frogKing = document.createElement('div');
  frogKing.className = 'tile king frog-king';
  frogKing.textContent = EMOJI.frogKing;
  boardEl.appendChild(frogKing);
  
  // All tiles
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.style.gridColumn = c + 1;
      tile.style.gridRow = r + 1;
      
      // Zone styling
      const zone = isKingZone(r, c);
      if (zone === 'duck') tile.classList.add('duck-zone');
      if (zone === 'frog') tile.classList.add('frog-zone');
      
      // Divider diagonal styling
      if (isDivider(r, c)) tile.classList.add('divider');
      
      // Check if tile is on ally path
      const getAllyPathType = () => {
        for (let i = 0; i < game.allies.length; i++) {
          const path = game.allyPaths[i];
          if (path && path.some(p => p.row === r && p.col === c)) {
            return game.allies[i].type;
          }
        }
        return null;
      };
      
      // Content
      let content = '';
      let extraClass = '';
      let badges = '';
      
      // Path visualization (before obstacles so it shows under them)
      const pathType = getAllyPathType();
      if (pathType && !findObstacle(r, c) && !findPlayer(r, c) && !findAlly(r, c)) {
        tile.classList.add(`ally-path-${pathType}`);
      }
      
      // Human player target path visualization
      if (game.humanPlayer) {
        const humanPath = game.players[game.humanPlayer].targetPath;
        if (humanPath && humanPath.some(p => p.row === r && p.col === c)) {
          tile.classList.add('player-path');
        }
      }
      
      // Obstacles
      const obstacle = findObstacle(r, c);
      if (obstacle) {
        content = obstacle.type === 'wave' ? EMOJI.wave : EMOJI.bush;
        extraClass = 'obstacle';
      }
      
      // Totems
      const totemKey = findTotem(r, c);
      if (totemKey) {
        content = totemKey === 'snake' ? EMOJI.snakeTotem : EMOJI.duckTotem;
        extraClass = 'totem';
      }
      
      // Allies
      const ally = findAlly(r, c);
      if (ally) {
        content = ally.type === 'duck' ? EMOJI.duckAlly : EMOJI.frogAlly;
        extraClass = 'ally';
      }
      
      // Players - don't render in tiles, use sprites instead
      // Just mark the tile
      const playerType = findPlayer(r, c);
      if (playerType) {
        extraClass = 'player';
      }
      
      tile.innerHTML = content + badges;
      if (extraClass) tile.classList.add(extraClass);
      
      // Click handler
      tile.onclick = () => handleTileClick(r, c);
      
      boardEl.appendChild(tile);
    }
  }
  
  // Update player sprite positions
  updatePlayerSprites();
}

// Update animated player sprites
function updatePlayerSprites() {
  const boardEl = document.getElementById('board');
  const boardRect = boardEl.getBoundingClientRect();
  const padding = 8;
  const gap = 3;
  
  const cellWidth = (boardRect.width - padding * 2 - gap * 8) / 9;
  const cellHeight = (boardRect.height - padding * 2 - gap * 14) / 15;
  
  // Duck sprite
  const duck = game.players.duck;
  const duckSprite = document.getElementById('duckSprite');
  duckSprite.style.width = cellWidth + 'px';
  duckSprite.style.height = cellHeight + 'px';
  duckSprite.style.fontSize = (cellHeight * 0.6) + 'px';
  duckSprite.style.left = (padding + duck.col * (cellWidth + gap)) + 'px';
  duckSprite.style.top = (padding + duck.row * (cellHeight + gap)) + 'px';
  document.getElementById('duckSpriteBadge').textContent = duck.hp;
  
  // Update totem indicator
  let duckTotem = duckSprite.querySelector('.totem-indicator');
  if (duck.hasTotem) {
    if (!duckTotem) {
      duckTotem = document.createElement('span');
      duckTotem.className = 'totem-indicator';
      duckSprite.appendChild(duckTotem);
    }
    duckTotem.textContent = EMOJI.duckTotem;
  } else if (duckTotem) {
    duckTotem.remove();
  }
  
  // Frog sprite
  const frog = game.players.frog;
  const frogSprite = document.getElementById('frogSprite');
  frogSprite.style.width = cellWidth + 'px';
  frogSprite.style.height = cellHeight + 'px';
  frogSprite.style.fontSize = (cellHeight * 0.6) + 'px';
  frogSprite.style.left = (padding + frog.col * (cellWidth + gap)) + 'px';
  frogSprite.style.top = (padding + frog.row * (cellHeight + gap)) + 'px';
  document.getElementById('frogSpriteBadge').textContent = frog.hp;
  
  // Update totem indicator
  let frogTotem = frogSprite.querySelector('.totem-indicator');
  if (frog.hasTotem) {
    if (!frogTotem) {
      frogTotem = document.createElement('span');
      frogTotem.className = 'totem-indicator';
      frogSprite.appendChild(frogTotem);
    }
    frogTotem.textContent = EMOJI.snakeTotem;
  } else if (frogTotem) {
    frogTotem.remove();
  }
}

function updateHUD() {
  // Update all HP displays (in game HUD)
  document.querySelectorAll('#duckHp').forEach(el => {
    el.textContent = `‚ù§Ô∏è ${game.players.duck.hp}`;
  });
  document.querySelectorAll('#frogHp').forEach(el => {
    el.textContent = `‚ù§Ô∏è ${game.players.frog.hp}`;
  });
  document.querySelectorAll('#duckTotem').forEach(el => {
    el.textContent = game.players.duck.hasTotem ? 'ü¶Ü' : '';
  });
  document.querySelectorAll('#frogTotem').forEach(el => {
    el.textContent = game.players.frog.hasTotem ? 'üêç' : '';
  });

  // Update turn info - simplified for game screen
  document.getElementById('turnInfo').textContent = `–¢—ñ–∫: ${game.tick}`;
}

// ============ GAME LOGIC ============
function handleTileClick(r, c) {
  if (game.gameOver || !game.gameStarted) return;
  if (!game.humanPlayer) return;

  const player = game.players[game.humanPlayer];

  // Can't click on kings
  if (isKingTile(r, c)) return;

  // Can't click on same tile
  if (player.row === r && player.col === c) return;

  const dist = distance(player.row, player.col, r, c);

  // –î–æ–∑–≤–æ–ª—è—î–º–æ –∫–ª—ñ–∫–∏ –Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å 1-2 –∫–ª—ñ—Ç–∏–Ω–∫–∏
  if (dist >= 1 && dist <= 2) {
    // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —à–ª—è—Ö –¥–æ —Ü—ñ–ª—ñ (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ pathfinding –¥–ª—è –≥—Ä–∞–≤—Ü—ñ–≤)
    const path = findPathForPlayer(player.row, player.col, r, c);
    if (path && path.length > 0 && path.length <= 2) {
      // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —à–ª—è—Ö - –º–æ–∂–Ω–∞ –∑–∞–≤–∂–¥–∏ –∑–º—ñ–Ω–∏—Ç–∏ –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ –Ω–∞ —ñ–Ω—à–µ –º—ñ—Å—Ü–µ
      player.targetPath = path;
      render();
    }
  }
}

function combat(attackerType, defenderType) {
  const attacker = game.players[attackerType];
  const defender = game.players[defenderType];
  
  let winner, loser;
  
  if (attacker.hp > defender.hp) {
    winner = attacker;
    loser = defender;
  } else if (defender.hp > attacker.hp) {
    winner = defender;
    loser = attacker;
  } else {
    // Random winner if equal
    if (Math.random() < 0.5) {
      winner = attacker;
      loser = defender;
    } else {
      winner = defender;
      loser = attacker;
    }
  }
  
  const loserType = loser === game.players.duck ? 'duck' : 'frog';
  
  // Winner loses HP equal to loser's HP (min 1)
  winner.hp = Math.max(1, winner.hp - loser.hp);
  
  // Loser drops totem if carrying
  if (loser.hasTotem) {
    const totemKey = loserType === 'duck' ? 'duck' : 'snake';
    game.totems[totemKey].row = loser.row;
    game.totems[totemKey].col = loser.col;
    game.totems[totemKey].pickedBy = null;
    loser.hasTotem = false;
  }
  
  // Loser respawns
  if (loserType === 'duck') {
    loser.row = 0;
    loser.col = 5;
  } else {
    loser.row = 14;
    loser.col = 3;
  }
  loser.hp = 1;
  loser.targetPath = []; // Clear path on death
}

function spawnAlly(type) {
  // Find empty tile near king
  const kingZoneTiles = [];
  
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === type && !isTileBlocked(r, c)) {
        kingZoneTiles.push({ r, c });
      }
    }
  }
  
  if (kingZoneTiles.length > 0) {
    const pos = kingZoneTiles[Math.floor(Math.random() * kingZoneTiles.length)];
    game.allies.push({ type, row: pos.r, col: pos.c });
  }
}

function updateAllyPaths() {
  game.allyPaths = {};
  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    if (ally.row < 0) continue;
    const player = game.players[ally.type];
    const path = findPath(ally.row, ally.col, player.row, player.col, false); // allies can't break obstacles
    if (path) {
      game.allyPaths[i] = path;
    }
  }
}

function moveAllies() {
  game.allyPaths = {}; // Clear paths

  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    if (ally.row < 0) continue; // Skip already removed

    const player = game.players[ally.type];

    // If reached player (adjacent), add HP
    if (distance(ally.row, ally.col, player.row, player.col) <= 1) {
      player.hp++;
      ally.row = -100; // Mark for removal
      continue;
    }

    // Use BFS to find optimal path - allies CAN'T break obstacles (false parameter)
    // If path is blocked by obstacles, ally won't move
    const path = findPath(ally.row, ally.col, player.row, player.col, false);
    if (path && path.length > 0) {
      const nextStep = path[0];

      // Check for enemy ally on next step - battle!
      const enemyAlly = findAlly(nextStep.row, nextStep.col);
      if (enemyAlly && enemyAlly.type !== ally.type) {
        // 50/50 random battle between allies
        if (Math.random() < 0.5) {
          // Current ally wins - enemy dies
          enemyAlly.row = -100;
        } else {
          // Enemy ally wins - current ally dies
          ally.row = -100;
        }
        continue;
      }

      // Check if next step is actually free (not blocked by own allies or obstacles)
      if (!enemyAlly && !findObstacle(nextStep.row, nextStep.col)) {
        // Store path for visualization
        game.allyPaths[i] = path;
        // Move to next step
        ally.row = nextStep.row;
        ally.col = nextStep.col;
      }
    }
  }

  // Remove dead/absorbed allies
  game.allies = game.allies.filter(a => a.row >= 0);
}

// BFS pathfinding for players - can walk through own allies, obstacles (break them)
function findPathForPlayer(fromR, fromC, toR, toC) {
  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, path: [] }];
  visited.add(`${fromR},${fromC}`);

  const directions = [
    { dr: -1, dc: 0 },  // up
    { dr: 1, dc: 0 },   // down
    { dr: 0, dc: -1 },  // left
    { dr: 0, dc: 1 }    // right
  ];

  while (queue.length > 0) {
    const current = queue.shift();

    // Found target
    if (current.r === toR && current.c === toC) {
      return current.path;
    }

    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const key = `${nr},${nc}`;

      if (visited.has(key)) continue;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      // Players can go through obstacles (they'll break them)
      // Players can go through allies (they'll kill enemy or absorb own)
      // Can't walk through enemy player (except as target for combat)
      const playerOnTile = findPlayer(nr, nc);
      if (playerOnTile && !(nr === toR && nc === toC)) continue;

      visited.add(key);
      const newPath = [...current.path, { row: nr, col: nc }];
      queue.push({ r: nr, c: nc, path: newPath });
    }
  }

  return null;
}

// BFS pathfinding for allies - can't break obstacles, avoids other allies
function findPath(fromR, fromC, toR, toC, allowObstacles = true) {
  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, path: [] }];
  visited.add(`${fromR},${fromC}`);

  const directions = [
    { dr: -1, dc: 0 },  // up
    { dr: 1, dc: 0 },   // down
    { dr: 0, dc: -1 },  // left
    { dr: 0, dc: 1 }    // right
  ];

  while (queue.length > 0) {
    const current = queue.shift();

    // Found target
    if (current.r === toR && current.c === toC) {
      return current.path;
    }

    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const key = `${nr},${nc}`;

      if (visited.has(key)) continue;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      // Allow obstacles if flag is set (player can break them)
      if (!allowObstacles && findObstacle(nr, nc)) continue;
      // Allies should avoid other allies (except target) to prevent blocking
      if (!allowObstacles && findAlly(nr, nc) && !(nr === toR && nc === toC)) continue;
      // Can't walk through players (except target)
      const playerOnTile = findPlayer(nr, nc);
      if (playerOnTile && !(nr === toR && nc === toC)) continue;
      
      visited.add(key);
      const newPath = [...current.path, { row: nr, col: nc }];
      queue.push({ r: nr, c: nc, path: newPath });
    }
  }
  
  return null; // No path found
}

// Get next step only (for compatibility)
function findNextStep(fromR, fromC, toR, toC) {
  const path = findPath(fromR, fromC, toR, toC);
  return path && path.length > 0 ? path[0] : null;
}

function gameWin(playerType) {
  game.gameOver = true;
  if (game.tickTimer) clearInterval(game.tickTimer);
  
  const emoji = playerType === 'duck' ? 'üê§' : 'üê∏';
  const name = playerType === 'duck' ? '–ö–∞—á–µ–Ω—è' : '–ñ–∞–±–∫–∞';
  const isHuman = playerType === game.humanPlayer;
  
  if (isHuman) {
    document.getElementById('winnerText').textContent = `üèÜ ${emoji} –ü–µ—Ä–µ–º–æ–≥–∞!`;
    document.getElementById('winnerDesc').textContent = `–¢–∏ –ø–µ—Ä–µ–º—ñ–≥! ${name} –¥–æ—Å—Ç–∞–≤–∏–≤ —Ç–æ—Ç–µ–º –∫–æ—Ä–æ–ª—é!`;
  } else {
    document.getElementById('winnerText').textContent = `üò¢ ${emoji} –ü—Ä–æ–≥—Ä–∞—à`;
    document.getElementById('winnerDesc').textContent = `AI –ø–µ—Ä–µ–º—ñ–≥. ${name} –¥–æ—Å—Ç–∞–≤–∏–≤ —Ç–æ—Ç–µ–º –∫–æ—Ä–æ–ª—é.`;
  }
  document.getElementById('winModal').classList.add('show');
}

function closeModal() {
  document.getElementById('winModal').classList.remove('show');
}

function resetGame() {
  closeModal();
  if (game.tickTimer) clearInterval(game.tickTimer);
  
  // Reset AI indicator
  document.querySelectorAll('.player-info').forEach(el => el.classList.remove('ai'));
  
  // Show character selection
  document.getElementById('selectModal').classList.add('show');
  
  initGame();
}

// ============ START ============
function selectCharacter(character) {
  game.humanPlayer = character;
  game.aiPlayer = character === 'duck' ? 'frog' : 'duck';
  game.gameStarted = true;

  // Show game screen
  showScreen('gameScreen');

  // Start the game tick
  startGameTick();

  render();
  updateHUD();
}

function startGameTick() {
  if (game.tickTimer) clearInterval(game.tickTimer);
  if (game.tickProgressTimer) cancelAnimationFrame(game.tickProgressTimer);

  // Reset progress bar
  const progressBar = document.getElementById('tickProgress');
  progressBar.classList.add('reset');
  progressBar.style.width = '0%';

  // Start tick timer
  game.tickStartTime = performance.now();

  game.tickTimer = setInterval(() => {
    if (!game.gameOver && game.gameStarted) {
      gameTick();
      // Reset progress after tick
      game.tickStartTime = performance.now();
      progressBar.classList.add('reset');
      progressBar.style.width = '0%';
      // Remove reset class after reflow
      requestAnimationFrame(() => {
        progressBar.classList.remove('reset');
      });
    }
  }, TICK_MS);

  // Start progress animation
  updateTickProgress();
}

function updateTickProgress() {
  if (game.gameOver || !game.gameStarted) return;

  const progressBar = document.getElementById('tickProgress');
  const elapsed = performance.now() - game.tickStartTime;
  const progress = Math.min((elapsed / TICK_MS) * 100, 100);

  progressBar.style.width = progress + '%';

  game.tickProgressTimer = requestAnimationFrame(updateTickProgress);
}

function gameTick() {
  game.tick++;
  
  // Spawn allies every 4 ticks
  if (game.tick % ALLY_SPAWN_TICKS === 0) {
    spawnAlly('duck');
    spawnAlly('frog');
  }
  
  // Move allies
  moveAllies();
  
  // Move human player one step if has path
  if (game.humanPlayer) {
    movePlayerOneStep(game.humanPlayer);
  }
  
  // AI makes one step
  aiMove();
  
  render();
  updateHUD();
}

// Move player one step along their path
function movePlayerOneStep(playerType) {
  const player = game.players[playerType];
  
  if (!player.targetPath || player.targetPath.length === 0) return;
  
  const nextStep = player.targetPath[0];
  
  // Check what's on next step
  const obstacle = findObstacle(nextStep.row, nextStep.col);
  const enemyType = findPlayer(nextStep.row, nextStep.col);
  const ally = findAlly(nextStep.row, nextStep.col);
  
  // Attack enemy player
  if (enemyType && enemyType !== playerType) {
    combat(playerType, enemyType);
    player.targetPath = []; // Clear path after combat
    return;
  }
  
  // Attack enemy ally (costs 1 HP)
  if (ally && ally.type !== playerType) {
    if (player.hp > 1) {
      player.hp--;
      // Add death animation to ally tile
      const allyTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (allyTile) {
        allyTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites();
      setTimeout(() => {
        game.allies = game.allies.filter(a => a !== ally);
        render();
      }, 250);
    }
    player.targetPath = []; // Clear path after action
    return;
  }

  // Absorb own ally (gains 1 HP, moves through them)
  if (ally && ally.type === playerType) {
    player.hp++;
    game.allies = game.allies.filter(a => a !== ally);
    // Continue moving - don't return, let the move happen below
  }
  
  // Break obstacle
  if (obstacle) {
    if (player.hp > 1) {
      player.hp--;
      // Add breaking animation
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites(); // Update sprite HP badge
      // Remove obstacle after animation
      setTimeout(() => {
        game.obstacles = game.obstacles.filter(o => o !== obstacle);
        render();
      }, 250);
    } else {
      // Show can't break feedback
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('cant-break');
        setTimeout(() => obstacleTile.classList.remove('cant-break'), 300);
      }
    }
    player.targetPath = []; // Clear path after action
    return;
  }
  
  // Check if tile is blocked by something else (obstacles handled above, allies handled above)
  // Only check for out of bounds, kings, and other players
  if (nextStep.row < 0 || nextStep.row >= ROWS || nextStep.col < 0 || nextStep.col >= COLS) {
    player.targetPath = [];
    return;
  }
  if (isKingTile(nextStep.row, nextStep.col)) {
    player.targetPath = [];
    return;
  }
  // If there's still an obstacle (player couldn't break it), stop
  if (findObstacle(nextStep.row, nextStep.col)) {
    player.targetPath = [];
    return;
  }

  // Move player
  player.row = nextStep.row;
  player.col = nextStep.col;
  player.targetPath.shift(); // Remove completed step
  
  // Pick up totem
  const totemKey = findTotem(player.row, player.col);
  if (totemKey) {
    const totem = game.totems[totemKey];
    if (totem.owner === playerType && !totem.pickedBy) {
      totem.pickedBy = playerType;
      player.hasTotem = true;
      totem.row = -1;
      totem.col = -1;
    }
  }
  
  // Check win condition
  if (player.hasTotem) {
    const zone = isKingZone(player.row, player.col);
    if (zone === playerType) {
      gameWin(playerType);
    }
  }
}

// ============ AI LOGIC ============
function aiMove() {
  if (!game.aiPlayer || game.gameOver) return;

  const ai = game.players[game.aiPlayer];

  // AI –ø–ª–∞–Ω—É—î —à–ª—è—Ö –Ω–∞ 1-2 –∫—Ä–æ–∫–∏ –∫–æ–∂–µ–Ω —Ç—ñ–∫ (—è–∫ –≥—Ä–∞–≤–µ—Ü—å)
  // –Ø–∫—â–æ –Ω–µ–º–∞—î —à–ª—è—Ö—É –∞–±–æ —à–ª—è—Ö –∑–∞–∫—ñ–Ω—á–∏–≤—Å—è - –ø–ª–∞–Ω—É—î–º–æ –Ω–æ–≤–∏–π
  if (!ai.targetPath || ai.targetPath.length === 0) {
    planAIPath();
  }

  // –í–∏–∫–æ–Ω—É—î–º–æ –æ–¥–∏–Ω –∫—Ä–æ–∫ (–≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç—É –∂ –ª–æ–≥—ñ–∫—É —â–æ —ñ –¥–ª—è –≥—Ä–∞–≤—Ü—è)
  movePlayerOneStep(game.aiPlayer);
}

function planAIPath() {
  const ai = game.players[game.aiPlayer];
  const human = game.players[game.humanPlayer];

  // Determine AI goal
  let targetR, targetC;

  if (ai.hasTotem) {
    // Has totem - go to king zone
    const kingZone = findNearestKingZone(game.aiPlayer, ai.row, ai.col);
    if (kingZone) {
      targetR = kingZone.row;
      targetC = kingZone.col;
    }
  } else {
    // Need totem - go get it
    const totemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
    const totem = game.totems[totemKey];
    if (totem.pickedBy === null) {
      targetR = totem.row;
      targetC = totem.col;
    }
  }

  if (targetR === undefined) return;

  // Find full path to target
  const fullPath = findPathForPlayer(ai.row, ai.col, targetR, targetC);

  if (fullPath && fullPath.length > 0) {
    // AI –ø–ª–∞–Ω—É—î –Ω–∞ 1-2 –∫—Ä–æ–∫–∏ –≤–ø–µ—Ä–µ–¥ (—è–∫ –≥—Ä–∞–≤–µ—Ü—å)
    ai.targetPath = fullPath.slice(0, 2);
  }
}

function findNearestKingZone(playerType, fromR, fromC) {
  let nearest = null;
  let minDist = Infinity;
  
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === playerType && !isTileBlocked(r, c)) {
        const d = distance(fromR, fromC, r, c);
        if (d < minDist) {
          minDist = d;
          nearest = { row: r, col: c };
        }
      }
    }
  }
  
  return nearest;
}

// ============ SETTINGS ============
let settings = {
  vibration: true,
  sound: false
};

function loadSettings() {
  try {
    const saved = localStorage.getItem('duckVsFrogSettings');
    if (saved) {
      settings = { ...settings, ...JSON.parse(saved) };
      updateSettingsUI();
    }
  } catch (e) {}
}

function saveSettings() {
  try {
    localStorage.setItem('duckVsFrogSettings', JSON.stringify(settings));
  } catch (e) {}
}

function updateSettingsUI() {
  // Toggles
  document.getElementById('vibrationToggle').classList.toggle('on', settings.vibration);
  document.getElementById('soundToggle').classList.toggle('on', settings.sound);
}

function toggleVibration() {
  settings.vibration = !settings.vibration;
  saveSettings();
  updateSettingsUI();
  if (settings.vibration && navigator.vibrate) {
    navigator.vibrate(50);
  }
}

function toggleSound() {
  settings.sound = !settings.sound;
  saveSettings();
  updateSettingsUI();
}

// ============ SCREEN NAVIGATION ============
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(screenId).classList.add('active');
}

// ============ TUTORIAL ============
let currentSlide = 0;
const totalSlides = 4;

function goToSlide(index) {
  currentSlide = index;
  document.querySelectorAll('.tutorial-slide').forEach((slide, i) => {
    slide.classList.toggle('active', i === index);
  });
  document.querySelectorAll('.tutorial-dot').forEach((dot, i) => {
    dot.classList.toggle('active', i === index);
  });
  // Update buttons
  document.getElementById('tutorialPrev').style.visibility = index === 0 ? 'hidden' : 'visible';
  document.getElementById('tutorialNext').textContent = index === totalSlides - 1 ? '–ì–æ—Ç–æ–≤–æ ‚úì' : '–î–∞–ª—ñ ‚Üí';
}

function nextSlide() {
  if (currentSlide < totalSlides - 1) {
    goToSlide(currentSlide + 1);
  } else {
    showScreen('menuScreen');
    goToSlide(0);
  }
}

function prevSlide() {
  if (currentSlide > 0) {
    goToSlide(currentSlide - 1);
  }
}

// ============ GAME CONTROLS ============
function pauseGame() {
  if (game.tickTimer) {
    clearInterval(game.tickTimer);
    game.tickTimer = null;
  }
  if (game.tickProgressTimer) {
    cancelAnimationFrame(game.tickProgressTimer);
    game.tickProgressTimer = null;
  }
  document.getElementById('pauseModal').classList.add('show');
}

function resumeGame() {
  document.getElementById('pauseModal').classList.remove('show');
  startGameTick();
}

function goToMenu() {
  if (game.tickTimer) {
    clearInterval(game.tickTimer);
    game.tickTimer = null;
  }
  if (game.tickProgressTimer) {
    cancelAnimationFrame(game.tickProgressTimer);
    game.tickProgressTimer = null;
  }
  document.getElementById('pauseModal').classList.remove('show');
  document.getElementById('winModal').classList.remove('show');
  showScreen('menuScreen');
  initGame();
}

function vibrate(pattern) {
  if (settings.vibration && navigator.vibrate) {
    navigator.vibrate(pattern);
  }
}

// ============ INIT ============
loadSettings();
initGame();

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (game.tickTimer) clearInterval(game.tickTimer);
});
</script>
</body>
</html>
