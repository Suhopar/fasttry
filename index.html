<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>üê§ vs üê∏</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #e0e5ec;
      --shadow-d: #a3b1c6;
      --shadow-l: #ffffff;
      --duck-color: rgba(247, 220, 111, 0.4);
      --frog-color: rgba(139, 195, 74, 0.4);
      --divider-color: rgba(120, 130, 150, 0.3);
    }
    html, body { 
      height: 100%; 
      overflow: hidden;
      touch-action: manipulation;
    }
    body {
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', system-ui, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 10px;
    }

    /* HUD */
    .hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 320px;
      margin-bottom: 10px;
      gap: 10px;
    }
    .player-info {
      flex: 1;
      padding: 10px 15px;
      border-radius: 16px;
      background: var(--bg);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .player-info.duck { border: 2px solid var(--duck-color); }
    .player-info.frog { border: 2px solid var(--frog-color); }
    .player-icon { font-size: 1.5rem; }
    .player-hp {
      font-size: 1.2rem;
      font-weight: 700;
      color: #e74c3c;
    }
    .player-totem {
      font-size: 0.9rem;
      opacity: 0.7;
    }

    /* Board */
    .board-container {
      position: relative;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(15, 1fr);
      gap: 3px;
      width: min(calc(100vw - 20px), 300px);
      aspect-ratio: 9 / 15;
      padding: 8px;
      border-radius: 16px;
      background: var(--bg);
      box-shadow:
        8px 8px 16px var(--shadow-d),
        -8px -8px 16px var(--shadow-l);
      position: relative;
      z-index: 1;
    }

    /* Tiles */
    .tile {
      border-radius: 6px;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      cursor: pointer;
      position: relative;
      box-shadow:
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l);
      transition: transform 0.1s, box-shadow 0.1s;
      border: 2px solid transparent;
    }
    .tile:active {
      transform: scale(0.95);
      box-shadow: 
        inset 2px 2px 4px var(--shadow-d),
        inset -2px -2px 4px var(--shadow-l);
    }
    
    /* Divider diagonal - tiles on the diagonal line */
    .tile.divider {
      border: 2px solid rgba(120, 130, 150, 0.5);
    }

    /* King zones */
    .tile.duck-zone {
      border-color: var(--duck-color);
    }
    .tile.frog-zone {
      border-color: var(--frog-color);
    }

    /* Kings */
    .tile.king {
      grid-column: span 2;
      grid-row: span 2;
      font-size: 2rem;
      cursor: default;
      border-radius: 10px;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .tile.duck-king {
      grid-column: 8 / 10;
      grid-row: 1 / 3;
      border: 3px solid var(--duck-color);
    }
    .tile.frog-king {
      grid-column: 1 / 3;
      grid-row: 14 / 16;
      border: 3px solid var(--frog-color);
    }

    /* Game objects */
    .tile.obstacle {
      background: rgba(200, 200, 200, 0.5);
    }
    .tile.obstacle.breaking {
      animation: obstacle-break 0.3s ease-out;
    }
    @keyframes obstacle-break {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    .tile.obstacle.cant-break {
      animation: obstacle-shake 0.3s ease-out;
    }
    @keyframes obstacle-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }
    
    .tile.player {
      z-index: 10;
      box-shadow: 
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    
    /* Animated player sprites */
    .player-sprite {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: var(--bg);
      z-index: 20;
      pointer-events: none;
      transition: left 0.3s ease-out, top 0.3s ease-out;
      box-shadow: 
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    .player-sprite .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .player-sprite .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 0.6rem;
      background: white;
      border-radius: 50%;
      padding: 2px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    
    .tile.ally {
      font-size: 0.7rem;
      opacity: 0.8;
    }
    .tile.ally.breaking {
      animation: obstacle-break 0.3s ease-out;
    }

    /* Animated ally sprites */
    .ally-sprite {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 5px;
      background: var(--bg);
      z-index: 15;
      pointer-events: none;
      transition: left 0.3s ease-out, top 0.3s ease-out, opacity 0.2s;
      font-size: 0.7rem;
      box-shadow:
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l);
    }
    .ally-sprite.duck-ally {
      border: 1px solid var(--duck-color);
    }
    .ally-sprite.frog-ally {
      border: 1px solid var(--frog-color);
    }
    .ally-sprite.dying {
      opacity: 0;
      transform: scale(0.5);
    }
    
    /* Path visualization for allies */
    .tile.ally-path-duck::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(247, 220, 111, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    .tile.ally-path-frog::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(139, 195, 74, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    
    /* Player target path visualization */
    .tile.player-path {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        inset 0 0 8px rgba(100, 150, 255, 0.4);
    }
    .tile.totem {
      animation: totem-glow 2s ease-in-out infinite;
    }
    @keyframes totem-glow {
      0%, 100% { box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l); }
      50% { box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l), 0 0 10px rgba(255, 215, 0, 0.5); }
    }

    /* Highlight for valid moves */
    .tile.highlight {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        0 0 0 3px rgba(100, 200, 100, 0.5);
    }

    /* Totem indicator on player */
    .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 0.6rem;
      background: white;
      border-radius: 50%;
      padding: 2px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    /* HP badge on player */
    .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    /* Controls */
    .controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: #333;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .btn:active {
      box-shadow: 
        inset 3px 3px 6px var(--shadow-d),
        inset -3px -3px 6px var(--shadow-l);
    }

    /* Turn indicator */
    .turn-info {
      margin-top: 10px;
      font-size: 0.8rem;
      color: #666;
      text-align: center;
    }

    /* Winner modal */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: var(--bg);
      padding: 30px 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow:
        10px 10px 20px var(--shadow-d),
        -10px -10px 20px var(--shadow-l);
    }
    .modal-content h2 {
      font-size: 2rem;
      margin-bottom: 10px;
    }
    .modal-content p {
      font-size: 1rem;
      color: #666;
      margin-bottom: 20px;
    }
    
    /* Character selection */
    .select-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
    }
    .select-btn {
      padding: 20px 30px;
      border: none;
      border-radius: 16px;
      background: var(--bg);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      transition: all 0.2s;
    }
    .select-btn:hover {
      transform: scale(1.05);
    }
    .select-btn:active {
      box-shadow: 
        inset 4px 4px 8px var(--shadow-d),
        inset -4px -4px 8px var(--shadow-l);
    }
    .select-btn.duck-select:hover {
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--duck-color);
    }
    .select-btn.frog-select:hover {
      box-shadow: 
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--frog-color);
    }
    .select-icon {
      font-size: 3rem;
    }
    .select-name {
      font-size: 1rem;
      font-weight: 600;
      color: #333;
    }
    
    /* AI indicator */
    .player-info.ai::after {
      content: 'ü§ñ';
      margin-left: 5px;
    }

    /* ============ SCREENS ============ */
    .screen {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--bg);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 50;
      overflow: hidden;
    }
    .screen.active { display: flex; }

    /* Main Menu */
    .menu-title {
      font-size: 3rem;
      margin-bottom: 10px;
    }
    .menu-subtitle {
      font-size: 1.2rem;
      color: #666;
      margin-bottom: 40px;
    }
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 100%;
      max-width: 250px;
    }
    .menu-btn {
      padding: 18px 30px;
      border: none;
      border-radius: 16px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: #333;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      transition: all 0.2s;
    }
    .menu-btn:active {
      box-shadow:
        inset 4px 4px 8px var(--shadow-d),
        inset -4px -4px 8px var(--shadow-l);
    }
    .menu-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    /* Settings Screen */
    .settings-container {
      width: 100%;
      max-width: 320px;
    }
    .settings-title {
      font-size: 1.5rem;
      margin-bottom: 25px;
      text-align: center;
    }
    .setting-item {
      background: var(--bg);
      padding: 15px 20px;
      border-radius: 12px;
      margin-bottom: 15px;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .setting-label {
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 0;
    }
    .setting-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .toggle-switch {
      width: 50px;
      height: 28px;
      background: var(--shadow-d);
      border-radius: 14px;
      position: relative;
      cursor: pointer;
      transition: background 0.3s;
    }
    .toggle-switch.on {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: left 0.3s;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }
    .toggle-switch.on::after {
      left: 25px;
    }
    .back-btn {
      margin-top: 25px;
      padding: 12px 30px;
    }

    /* Tutorial Screen */
    .tutorial-container {
      width: 100%;
      max-width: 320px;
      text-align: center;
    }
    .tutorial-title {
      font-size: 1.5rem;
      margin-bottom: 20px;
    }
    .tutorial-slide {
      display: none;
      background: var(--bg);
      padding: 25px;
      border-radius: 16px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      min-height: 250px;
    }
    .tutorial-slide.active { display: block; }
    .tutorial-slide h3 {
      font-size: 1.2rem;
      margin-bottom: 15px;
    }
    .tutorial-slide p {
      font-size: 0.95rem;
      color: #555;
      line-height: 1.5;
    }
    .tutorial-slide .emoji-big {
      font-size: 3rem;
      margin-bottom: 15px;
    }
    .tutorial-nav {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }
    .tutorial-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--shadow-d);
      cursor: pointer;
    }
    .tutorial-dot.active {
      background: #667eea;
    }
    .tutorial-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      justify-content: center;
    }

    /* Game Screen - —Ç—ñ–ª—å–∫–∏ –ø–æ–ª–µ —ñ —ñ–Ω—Ñ–æ –≤–Ω–∏–∑—É */
    #gameScreen {
      padding: 10px;
      justify-content: space-between;
    }
    .game-top {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .game-bottom {
      width: 100%;
      max-width: 320px;
      padding-bottom: 10px;
    }
    .game-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      padding: 12px 20px;
      background: var(--bg);
      border-radius: 20px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
    }
    .panel-btn {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
      transition: all 0.15s;
    }
    .panel-btn:active {
      box-shadow:
        inset 3px 3px 6px var(--shadow-d),
        inset -3px -3px 6px var(--shadow-l);
    }

    /* Circular tick progress */
    .tick-ring-container {
      position: relative;
      width: 50px;
      height: 50px;
    }
    .tick-ring {
      width: 50px;
      height: 50px;
      transform: rotate(-90deg);
    }
    .tick-ring-bg {
      fill: none;
      stroke: var(--shadow-d);
      stroke-width: 3;
    }
    .tick-ring-progress {
      fill: none;
      stroke: url(#tickGradient);
      stroke-width: 3;
      stroke-linecap: round;
      stroke-dasharray: 97.39; /* 2 * PI * 15.5 */
      stroke-dashoffset: 97.39;
      transition: stroke-dashoffset 0.05s linear;
    }
    .tick-number {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.9rem;
      font-weight: 700;
      color: #555;
    }

    /* Character Select Modal - –æ–Ω–æ–≤–ª–µ–Ω–∏–π */
    .char-select-title {
      font-size: 1.3rem;
      margin-bottom: 20px;
    }

  </style>
</head>
<body>

<!-- SVG Gradient Definition -->
<svg width="0" height="0">
  <defs>
    <linearGradient id="tickGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#667eea"/>
      <stop offset="100%" stop-color="#764ba2"/>
    </linearGradient>
  </defs>
</svg>

<!-- ============ MAIN MENU SCREEN ============ -->
<div class="screen active" id="menuScreen">
  <div class="menu-title">üê§ vs üê∏</div>
  <div class="menu-subtitle">–ö–∞—á–∫–∞ –ø—Ä–æ—Ç–∏ –ñ–∞–±–∫–∏</div>
  <div class="menu-buttons">
    <button class="menu-btn primary" onclick="showScreen('selectScreen')">‚ñ∂Ô∏è –ì—Ä–∞—Ç–∏</button>
    <button class="menu-btn" onclick="showScreen('settingsScreen')">‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</button>
    <button class="menu-btn" onclick="showScreen('tutorialScreen')">üìñ –Ø–∫ –≥—Ä–∞—Ç–∏</button>
  </div>
</div>

<!-- ============ CHARACTER SELECT SCREEN ============ -->
<div class="screen" id="selectScreen">
  <h2 class="char-select-title">üéÆ –û–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
  <div class="select-buttons">
    <button class="select-btn duck-select" onclick="selectCharacter('duck')">
      <span class="select-icon">üê§</span>
      <span class="select-name">–ö–∞—á–µ–Ω—è</span>
    </button>
    <button class="select-btn frog-select" onclick="selectCharacter('frog')">
      <span class="select-icon">üê∏</span>
      <span class="select-name">–ñ–∞–±–∫–∞</span>
    </button>
  </div>
  <button class="btn back-btn" onclick="showScreen('menuScreen')">‚Üê –ù–∞–∑–∞–¥</button>
</div>

<!-- ============ SETTINGS SCREEN ============ -->
<div class="screen" id="settingsScreen">
  <div class="settings-container">
    <h2 class="settings-title">‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</h2>

    <div class="setting-item setting-toggle">
      <div class="setting-label">–í—ñ–±—Ä–∞—Ü—ñ—è</div>
      <div class="toggle-switch on" id="vibrationToggle" onclick="toggleVibration()"></div>
    </div>

    <div class="setting-item setting-toggle">
      <div class="setting-label">–ó–≤—É–∫–∏</div>
      <div class="toggle-switch" id="soundToggle" onclick="toggleSound()"></div>
    </div>

    <button class="btn back-btn" onclick="showScreen('menuScreen')">‚Üê –ù–∞–∑–∞–¥</button>
  </div>
</div>

<!-- ============ TUTORIAL SCREEN ============ -->
<div class="screen" id="tutorialScreen">
  <div class="tutorial-container">
    <h2 class="tutorial-title">üìñ –Ø–∫ –≥—Ä–∞—Ç–∏</h2>

    <div class="tutorial-slide active" data-slide="0">
      <div class="emoji-big">üéØ</div>
      <h3>–ú–µ—Ç–∞ –≥—Ä–∏</h3>
      <p>–ó–∞–±–µ—Ä–∏ —Å–≤—ñ–π —Ç–æ—Ç–µ–º –∑ –≤–æ—Ä–æ–∂–æ—ó —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—ó —Ç–∞ –¥–æ–Ω–µ—Å–∏ –π–æ–≥–æ –¥–æ —Å–≤–æ–≥–æ –ö–æ—Ä–æ–ª—è!</p>
    </div>

    <div class="tutorial-slide" data-slide="1">
      <div class="emoji-big">üëÜ</div>
      <h3>–ö–µ—Ä—É–≤–∞–Ω–Ω—è</h3>
      <p>–ö–ª—ñ–∫–Ω–∏ –Ω–∞ –∫–ª—ñ—Ç–∏–Ω–∫—É —â–æ–± —Ä—É—Ö–∞—Ç–∏—Å—å. –ö–ª—ñ–∫–Ω–∏ –Ω–∞ –≤–æ—Ä–æ–≥–∞ —â–æ–± –∞—Ç–∞–∫—É–≤–∞—Ç–∏. –ö–ª—ñ–∫–Ω–∏ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É —â–æ–± –∑–ª–∞–º–∞—Ç–∏.</p>
    </div>

    <div class="tutorial-slide" data-slide="2">
      <div class="emoji-big">‚ù§Ô∏è</div>
      <h3>HP —Å–∏—Å—Ç–µ–º–∞</h3>
      <p>–°–æ—é–∑–Ω–∏–∫–∏ üê£ –ø—Ä–∏–Ω–æ—Å—è—Ç—å +1 HP. –õ–∞–º–∞–Ω–Ω—è –ø–µ—Ä–µ—à–∫–æ–¥ –∫–æ—à—Ç—É—î -1 HP. –í –±–æ—é –ø–µ—Ä–µ–º–∞–≥–∞—î —Ç–æ–π, —É –∫–æ–≥–æ –±—ñ–ª—å—à–µ HP!</p>
    </div>

    <div class="tutorial-slide" data-slide="3">
      <div class="emoji-big">üèÜ</div>
      <h3>–ü–µ—Ä–µ–º–æ–≥–∞</h3>
      <p>–ü—ñ–¥–±–µ—Ä–∏ —Å–≤—ñ–π —Ç–æ—Ç–µ–º —ñ –∑–∞–Ω–µ—Å–∏ –π–æ–≥–æ –≤ –∑–æ–Ω—É –±—ñ–ª—è —Å–≤–æ–≥–æ –ö–æ—Ä–æ–ª—è. –ê–ª–µ –±–µ—Ä–µ–∂–∏—Å—å –≤–æ—Ä–æ–≥–∞!</p>
    </div>

    <div class="tutorial-nav">
      <div class="tutorial-dot active" onclick="goToSlide(0)"></div>
      <div class="tutorial-dot" onclick="goToSlide(1)"></div>
      <div class="tutorial-dot" onclick="goToSlide(2)"></div>
      <div class="tutorial-dot" onclick="goToSlide(3)"></div>
    </div>

    <div class="tutorial-buttons">
      <button class="btn" id="tutorialPrev" onclick="prevSlide()" style="visibility: hidden;">‚Üê –ù–∞–∑–∞–¥</button>
      <button class="btn" id="tutorialNext" onclick="nextSlide()">–î–∞–ª—ñ ‚Üí</button>
    </div>
  </div>
</div>

<!-- ============ GAME SCREEN ============ -->
<div class="screen" id="gameScreen">
  <div class="game-top">
    <div class="board-container">
      <div class="board" id="board"></div>
      <div id="allySpritesContainer"></div>
      <div class="player-sprite" id="duckSprite">üê•<span class="hp-badge" id="duckSpriteBadge">1</span></div>
      <div class="player-sprite" id="frogSprite">üê∏<span class="hp-badge" id="frogSpriteBadge">1</span></div>
    </div>
  </div>

  <div class="game-bottom">
    <div class="game-panel">
      <button class="panel-btn" onclick="pauseGame()">‚è∏Ô∏è</button>
      <div class="tick-ring-container">
        <svg class="tick-ring" viewBox="0 0 36 36">
          <circle class="tick-ring-bg" cx="18" cy="18" r="15.5"></circle>
          <circle class="tick-ring-progress" id="tickRing" cx="18" cy="18" r="15.5"></circle>
        </svg>
        <span class="tick-number" id="tickNumber">0</span>
      </div>
      <button class="panel-btn" onclick="goToMenu()">üè†</button>
    </div>
  </div>
</div>

<!-- Winner Modal -->
<div class="modal" id="winModal">
  <div class="modal-content">
    <h2 id="winnerText">üèÜ</h2>
    <p id="winnerDesc">–ü–µ—Ä–µ–º—ñ–≥!</p>
    <button class="btn" onclick="goToMenu()">üè† –í –º–µ–Ω—é</button>
  </div>
</div>

<!-- Pause Modal -->
<div class="modal" id="pauseModal">
  <div class="modal-content">
    <h2>‚è∏Ô∏è –ü–∞—É–∑–∞</h2>
    <p>–ì—Ä–∞ –Ω–∞ –ø–∞—É–∑—ñ</p>
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <button class="btn" onclick="resumeGame()">‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏</button>
      <button class="btn" onclick="goToMenu()">üè† –í –º–µ–Ω—é</button>
    </div>
  </div>
</div>

<script>
// ============ CONSTANTS ============
const COLS = 9, ROWS = 15;
const TICK_MS = 1000; // 1 second per tick
const ALLY_SPAWN_TICKS = 6; // 6 sec / 1 sec = 6 ticks
const OBSTACLE_DENSITY = 0.70; // 70% chance per valid tile (more obstacles)
const MIN_OBSTACLES_PER_ZONE = 8; // –ú—ñ–Ω—ñ–º—É–º –ø–µ—Ä–µ—à–∫–æ–¥ –Ω–∞ –∫–æ–∂–Ω—É –∑–æ–Ω—É

// Diagonal divider from (col 0, row 3) to (col 8, row 11) in 0-indexed
// In 1-indexed: (1, 4) to (9, 12)

// Emoji
const EMOJI = {
  duckKing: 'üê§',
  frogKing: 'üê∏',
  duckPlayer: 'üê•',
  frogPlayer: 'üê∏',
  duckAlly: 'üê£',
  frogAlly: 'üê∏',
  snakeTotem: 'üêç',
  duckTotem: 'ü¶Ü',
  wave: 'üåä',
  bush: 'üåø'
};

// ============ GAME STATE ============
let game = {
  tick: 0,
  tickTimer: null,
  
  humanPlayer: null, // 'duck' or 'frog'
  aiPlayer: null,    // opposite of humanPlayer
  
  players: {
    duck: { row: 0, col: 5, hp: 1, hasTotem: false, targetPath: [] },
    frog: { row: 14, col: 3, hp: 1, hasTotem: false, targetPath: [] }
  },
  
  totems: {
    snake: { row: 0, col: 0, owner: 'frog', pickedBy: null },
    duck: { row: 14, col: 8, owner: 'duck', pickedBy: null }
  },
  
  allies: [],
  allyPaths: {}, // Store paths for visualization
  obstacles: [],

  gameOver: false,
  gameStarted: false,

  // Tick progress animation
  tickProgressTimer: null,
  tickStartTime: 0
};

// ============ HELPERS ============
const isKingTile = (r, c) => {
  // Duck king: cols 7-8, rows 0-1
  if (c >= 7 && c <= 8 && r >= 0 && r <= 1) return 'duck';
  // Frog king: cols 0-1, rows 13-14
  if (c >= 0 && c <= 1 && r >= 13 && r <= 14) return 'frog';
  return null;
};

const isKingZone = (r, c) => {
  // Duck zone: around duck king (cols 6-8, rows 0-2, excluding king)
  if (c >= 6 && c <= 8 && r >= 0 && r <= 2 && !isKingTile(r, c)) {
    if (c === 6 || r === 2) return 'duck';
  }
  // Frog zone: around frog king (cols 0-2, rows 12-14, excluding king)
  if (c >= 0 && c <= 2 && r >= 12 && r <= 14 && !isKingTile(r, c)) {
    if (c === 2 || r === 12) return 'frog';
  }
  return null;
};

// Diagonal: row = col + 3
const isDivider = (r, c) => r === c + 3;

const getTerritory = (r, c) => {
  // Above diagonal (r < c + 3) = duck territory (top-right)
  // Below diagonal (r > c + 3) = frog territory (bottom-left)
  if (r < c + 3) return 'duck';
  if (r > c + 3) return 'frog';
  return 'neutral'; // On the diagonal
};

const findObstacle = (r, c) => game.obstacles.find(o => o.row === r && o.col === c);
const findAlly = (r, c) => game.allies.find(a => a.row === r && a.col === c);
const findPlayer = (r, c) => {
  if (game.players.duck.row === r && game.players.duck.col === c) return 'duck';
  if (game.players.frog.row === r && game.players.frog.col === c) return 'frog';
  return null;
};
const findTotem = (r, c) => {
  for (let key in game.totems) {
    const t = game.totems[key];
    if (t.row === r && t.col === c && !t.pickedBy) return key;
  }
  return null;
};

const isTileBlocked = (r, c) => {
  if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true;
  if (isKingTile(r, c)) return true;
  if (findObstacle(r, c)) return true;
  if (findPlayer(r, c)) return true;
  if (findAlly(r, c)) return true;
  return false;
};

const distance = (r1, c1, r2, c2) => Math.abs(r1 - r2) + Math.abs(c1 - c2);

// ============ INIT ============
function initGame() {
  game.tick = 0;
  game.gameOver = false;
  game.gameStarted = false;
  game.humanPlayer = null;
  game.aiPlayer = null;
  
  // Reset players
  game.players.duck = { row: 0, col: 5, hp: 1, hasTotem: false, targetPath: [] };
  game.players.frog = { row: 14, col: 3, hp: 1, hasTotem: false, targetPath: [] };
  
  // Reset totems
  game.totems.snake = { row: 0, col: 0, owner: 'frog', pickedBy: null };
  game.totems.duck = { row: 14, col: 8, owner: 'duck', pickedBy: null };
  
  // Clear allies
  game.allies = [];
  game.allyPaths = {};

  // Clear ally sprites
  const allyContainer = document.getElementById('allySpritesContainer');
  if (allyContainer) allyContainer.innerHTML = '';

  // Generate obstacles - symmetric for both sides
  game.obstacles = [];

  // Helper: check if tile is near a totem (within 2 tiles)
  const isNearSnakeTotem = (r, c) => distance(r, c, 0, 0) <= 2;
  const isNearDuckTotem = (r, c) => distance(r, c, 14, 8) <= 2;

  // Collect valid tiles - separate near-totem and far tiles
  const duckTilesNearTotem = []; // Near snake totem (duck territory, row 0 area)
  const duckTilesFar = [];
  const frogTilesNearTotem = []; // Near duck totem (frog territory, row 14 area)
  const frogTilesFar = [];

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      if (isKingZone(r, c)) continue;
      if (isDivider(r, c)) continue;

      // Don't place on player start positions
      if (r === 0 && c === 5) continue; // duck start
      if (r === 14 && c === 3) continue; // frog start

      // Don't place on totem positions
      if (r === 0 && c === 0) continue; // snake totem
      if (r === 14 && c === 8) continue; // duck totem

      const territory = getTerritory(r, c);
      if (territory === 'duck') {
        if (isNearSnakeTotem(r, c)) {
          duckTilesNearTotem.push({ row: r, col: c });
        } else {
          duckTilesFar.push({ row: r, col: c });
        }
      } else if (territory === 'frog') {
        if (isNearDuckTotem(r, c)) {
          frogTilesNearTotem.push({ row: r, col: c });
        } else {
          frogTilesFar.push({ row: r, col: c });
        }
      }
    }
  }

  // Shuffle arrays
  const shuffle = arr => {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  shuffle(duckTilesNearTotem);
  shuffle(duckTilesFar);
  shuffle(frogTilesNearTotem);
  shuffle(frogTilesFar);

  // Place equal obstacles near totems (both sides get same amount)
  // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ Math.max –¥–ª—è –≥–∞—Ä–∞–Ω—Ç—ñ—ó –º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ
  const nearTotemCount = Math.max(
    MIN_OBSTACLES_PER_ZONE,
    Math.min(
      Math.floor(duckTilesNearTotem.length * OBSTACLE_DENSITY),
      Math.floor(frogTilesNearTotem.length * OBSTACLE_DENSITY)
    )
  );

  for (let i = 0; i < nearTotemCount; i++) {
    if (duckTilesNearTotem[i]) {
      game.obstacles.push({ row: duckTilesNearTotem[i].row, col: duckTilesNearTotem[i].col, type: 'wave' });
    }
    if (frogTilesNearTotem[i]) {
      game.obstacles.push({ row: frogTilesNearTotem[i].row, col: frogTilesNearTotem[i].col, type: 'bush' });
    }
  }

  // Place equal obstacles in far areas
  const farCount = Math.max(
    MIN_OBSTACLES_PER_ZONE,
    Math.min(
      Math.floor(duckTilesFar.length * OBSTACLE_DENSITY),
      Math.floor(frogTilesFar.length * OBSTACLE_DENSITY)
    )
  );

  for (let i = 0; i < farCount; i++) {
    if (duckTilesFar[i]) {
      game.obstacles.push({ row: duckTilesFar[i].row, col: duckTilesFar[i].col, type: 'wave' });
    }
    if (frogTilesFar[i]) {
      game.obstacles.push({ row: frogTilesFar[i].row, col: frogTilesFar[i].col, type: 'bush' });
    }
  }
  
  render();
  updateHUD();
}

// ============ RENDER ============
function render() {
  // Update ally paths for visualization
  updateAllyPaths();
  
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  
  // Kings first
  const duckKing = document.createElement('div');
  duckKing.className = 'tile king duck-king';
  duckKing.textContent = EMOJI.duckKing;
  boardEl.appendChild(duckKing);
  
  const frogKing = document.createElement('div');
  frogKing.className = 'tile king frog-king';
  frogKing.textContent = EMOJI.frogKing;
  boardEl.appendChild(frogKing);
  
  // All tiles
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.style.gridColumn = c + 1;
      tile.style.gridRow = r + 1;
      
      // Zone styling
      const zone = isKingZone(r, c);
      if (zone === 'duck') tile.classList.add('duck-zone');
      if (zone === 'frog') tile.classList.add('frog-zone');
      
      // Divider diagonal styling
      if (isDivider(r, c)) tile.classList.add('divider');
      
      // Check if tile is on ally path
      const getAllyPathType = () => {
        for (let i = 0; i < game.allies.length; i++) {
          const path = game.allyPaths[i];
          if (path && path.some(p => p.row === r && p.col === c)) {
            return game.allies[i].type;
          }
        }
        return null;
      };
      
      // Content
      let content = '';
      let extraClass = '';
      let badges = '';
      
      // Path visualization (before obstacles so it shows under them)
      const pathType = getAllyPathType();
      if (pathType && !findObstacle(r, c) && !findPlayer(r, c) && !findAlly(r, c)) {
        tile.classList.add(`ally-path-${pathType}`);
      }
      
      // Human player target path visualization
      if (game.humanPlayer) {
        const humanPath = game.players[game.humanPlayer].targetPath;
        if (humanPath && humanPath.some(p => p.row === r && p.col === c)) {
          tile.classList.add('player-path');
        }
      }
      
      // Obstacles
      const obstacle = findObstacle(r, c);
      if (obstacle) {
        content = obstacle.type === 'wave' ? EMOJI.wave : EMOJI.bush;
        extraClass = 'obstacle';
      }
      
      // Totems
      const totemKey = findTotem(r, c);
      if (totemKey) {
        content = totemKey === 'snake' ? EMOJI.snakeTotem : EMOJI.duckTotem;
        extraClass = 'totem';
      }
      
      // Allies - don't render in tiles, use sprites instead
      // Just mark the tile
      const ally = findAlly(r, c);
      if (ally) {
        extraClass = 'ally';
      }

      // Players - don't render in tiles, use sprites instead
      // Just mark the tile
      const playerType = findPlayer(r, c);
      if (playerType) {
        extraClass = 'player';
      }
      
      tile.innerHTML = content + badges;
      if (extraClass) tile.classList.add(extraClass);

      boardEl.appendChild(tile);
    }
  }
  
  // Update player sprite positions
  updatePlayerSprites();
  // Update ally sprite positions
  updateAllySprites();
}

// Update animated ally sprites
function updateAllySprites() {
  const boardEl = document.getElementById('board');
  const boardRect = boardEl.getBoundingClientRect();
  const container = document.getElementById('allySpritesContainer');
  const padding = 8;
  const gap = 3;

  const cellWidth = (boardRect.width - padding * 2 - gap * 8) / 9;
  const cellHeight = (boardRect.height - padding * 2 - gap * 14) / 15;

  // Get current sprites
  const existingSprites = container.querySelectorAll('.ally-sprite');
  const existingMap = new Map();
  existingSprites.forEach(sprite => {
    existingMap.set(sprite.dataset.allyId, sprite);
  });

  // Track which allies still exist
  const currentAllyIds = new Set();

  game.allies.forEach((ally, index) => {
    if (ally.row < 0) return; // Skip removed allies

    const allyId = ally.id || (ally.id = 'ally_' + Date.now() + '_' + index + '_' + Math.random());
    currentAllyIds.add(allyId);

    let sprite = existingMap.get(allyId);

    if (!sprite) {
      // Create new sprite
      sprite = document.createElement('div');
      sprite.className = `ally-sprite ${ally.type}-ally`;
      sprite.dataset.allyId = allyId;
      sprite.textContent = ally.type === 'duck' ? EMOJI.duckAlly : EMOJI.frogAlly;
      sprite.style.width = (cellWidth * 0.85) + 'px';
      sprite.style.height = (cellHeight * 0.85) + 'px';
      sprite.style.fontSize = (cellHeight * 0.5) + 'px';
      container.appendChild(sprite);
    }

    // Update position (with animation via CSS transition)
    const offsetX = (cellWidth - cellWidth * 0.85) / 2;
    const offsetY = (cellHeight - cellHeight * 0.85) / 2;
    sprite.style.left = (padding + ally.col * (cellWidth + gap) + offsetX) + 'px';
    sprite.style.top = (padding + ally.row * (cellHeight + gap) + offsetY) + 'px';
  });

  // Remove sprites for dead allies with fade out
  existingSprites.forEach(sprite => {
    if (!currentAllyIds.has(sprite.dataset.allyId)) {
      sprite.classList.add('dying');
      setTimeout(() => sprite.remove(), 200);
    }
  });
}

// Update animated player sprites
function updatePlayerSprites() {
  const boardEl = document.getElementById('board');
  const boardRect = boardEl.getBoundingClientRect();
  const padding = 8;
  const gap = 3;
  
  const cellWidth = (boardRect.width - padding * 2 - gap * 8) / 9;
  const cellHeight = (boardRect.height - padding * 2 - gap * 14) / 15;
  
  // Duck sprite
  const duck = game.players.duck;
  const duckSprite = document.getElementById('duckSprite');
  duckSprite.style.width = cellWidth + 'px';
  duckSprite.style.height = cellHeight + 'px';
  duckSprite.style.fontSize = (cellHeight * 0.6) + 'px';
  duckSprite.style.left = (padding + duck.col * (cellWidth + gap)) + 'px';
  duckSprite.style.top = (padding + duck.row * (cellHeight + gap)) + 'px';
  document.getElementById('duckSpriteBadge').textContent = duck.hp;
  
  // Update totem indicator
  let duckTotem = duckSprite.querySelector('.totem-indicator');
  if (duck.hasTotem) {
    if (!duckTotem) {
      duckTotem = document.createElement('span');
      duckTotem.className = 'totem-indicator';
      duckSprite.appendChild(duckTotem);
    }
    duckTotem.textContent = EMOJI.duckTotem;
  } else if (duckTotem) {
    duckTotem.remove();
  }
  
  // Frog sprite
  const frog = game.players.frog;
  const frogSprite = document.getElementById('frogSprite');
  frogSprite.style.width = cellWidth + 'px';
  frogSprite.style.height = cellHeight + 'px';
  frogSprite.style.fontSize = (cellHeight * 0.6) + 'px';
  frogSprite.style.left = (padding + frog.col * (cellWidth + gap)) + 'px';
  frogSprite.style.top = (padding + frog.row * (cellHeight + gap)) + 'px';
  document.getElementById('frogSpriteBadge').textContent = frog.hp;
  
  // Update totem indicator
  let frogTotem = frogSprite.querySelector('.totem-indicator');
  if (frog.hasTotem) {
    if (!frogTotem) {
      frogTotem = document.createElement('span');
      frogTotem.className = 'totem-indicator';
      frogSprite.appendChild(frogTotem);
    }
    frogTotem.textContent = EMOJI.snakeTotem;
  } else if (frogTotem) {
    frogTotem.remove();
  }
}

function updateHUD() {
  // Update tick number in ring
  const tickNumber = document.getElementById('tickNumber');
  if (tickNumber) {
    tickNumber.textContent = game.tick;
  }
}

// ============ GAME LOGIC ============
function handleTileClick(r, c) {
  if (game.gameOver || !game.gameStarted) return;
  if (!game.humanPlayer) return;

  const player = game.players[game.humanPlayer];

  // Can't click on kings
  if (isKingTile(r, c)) return;

  // Can't click on same tile
  if (player.row === r && player.col === c) return;

  const dist = distance(player.row, player.col, r, c);

  // –î–æ–∑–≤–æ–ª—è—î–º–æ –∫–ª—ñ–∫–∏ –Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—å 1-2 –∫–ª—ñ—Ç–∏–Ω–∫–∏
  if (dist >= 1 && dist <= 2) {
    // –í–∏–∑–Ω–∞—á–∞—î–º–æ —á–∏ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É
    const clickedObstacle = findObstacle(r, c);

    let path;
    if (clickedObstacle) {
      // –Ø–∫—â–æ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É - —à–ª—è—Ö –º–æ–∂–µ –π—Ç–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥–∏
      path = findPathForPlayer(player.row, player.col, r, c);
    } else {
      // –Ø–∫—â–æ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –ø—É—Å—Ç—É –∫–ª—ñ—Ç–∏–Ω—É - —Å–ø–æ—á–∞—Ç–∫—É —à—É–∫–∞—î–º–æ —à–ª—è—Ö –±–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥
      path = findPath(player.row, player.col, r, c, false);
      // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏ - —Å–ø—Ä–æ–±—É—î–º–æ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥–∏
      if (!path || path.length === 0 || path.length > 2) {
        path = findPathForPlayer(player.row, player.col, r, c);
      }
    }

    if (path && path.length > 0 && path.length <= 2) {
      // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —à–ª—è—Ö
      player.targetPath = path;
      // –û–Ω–æ–≤–ª—é—î–º–æ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é —à–ª—è—Ö—É
      updatePathVisualization();
    }
  }
}

// –û–Ω–æ–≤–ª—é—î –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é —à–ª—è—Ö—É –±–µ–∑ –ø–æ–≤–Ω–æ—ó –ø–µ—Ä–µ–±—É–¥–æ–≤–∏ DOM
function updatePathVisualization() {
  // –û—á–∏—Å—Ç–∏—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ —à–ª—è—Ö–∏
  document.querySelectorAll('.tile.player-path').forEach(t => t.classList.remove('player-path'));

  // –ü–æ–∫–∞–∑–∞—Ç–∏ –Ω–æ–≤–∏–π —à–ª—è—Ö
  if (game.humanPlayer) {
    const humanPath = game.players[game.humanPlayer].targetPath;
    if (humanPath) {
      humanPath.forEach(p => {
        const tile = document.querySelector(`.tile[data-row="${p.row}"][data-col="${p.col}"]`);
        if (tile) tile.classList.add('player-path');
      });
    }
  }
}

function combat(attackerType, defenderType) {
  const attacker = game.players[attackerType];
  const defender = game.players[defenderType];
  
  let winner, loser;
  
  if (attacker.hp > defender.hp) {
    winner = attacker;
    loser = defender;
  } else if (defender.hp > attacker.hp) {
    winner = defender;
    loser = attacker;
  } else {
    // Random winner if equal
    if (Math.random() < 0.5) {
      winner = attacker;
      loser = defender;
    } else {
      winner = defender;
      loser = attacker;
    }
  }
  
  const loserType = loser === game.players.duck ? 'duck' : 'frog';
  
  // Winner loses HP equal to loser's HP (min 1)
  winner.hp = Math.max(1, winner.hp - loser.hp);
  
  // Loser drops totem if carrying
  if (loser.hasTotem) {
    const totemKey = loserType === 'duck' ? 'duck' : 'snake';
    game.totems[totemKey].row = loser.row;
    game.totems[totemKey].col = loser.col;
    game.totems[totemKey].pickedBy = null;
    loser.hasTotem = false;
  }
  
  // Loser respawns
  if (loserType === 'duck') {
    loser.row = 0;
    loser.col = 5;
  } else {
    loser.row = 14;
    loser.col = 3;
  }
  loser.hp = 1;
  loser.targetPath = []; // Clear path on death
}

function spawnAlly(type) {
  // Find empty tile near king
  const kingZoneTiles = [];
  
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === type && !isTileBlocked(r, c)) {
        kingZoneTiles.push({ r, c });
      }
    }
  }
  
  if (kingZoneTiles.length > 0) {
    const pos = kingZoneTiles[Math.floor(Math.random() * kingZoneTiles.length)];
    game.allies.push({ type, row: pos.r, col: pos.c });
  }
}

function updateAllyPaths() {
  game.allyPaths = {};
  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    if (ally.row < 0) continue;
    const player = game.players[ally.type];
    const path = findPath(ally.row, ally.col, player.row, player.col, false); // allies can't break obstacles
    if (path) {
      game.allyPaths[i] = path;
    }
  }
}

function moveAllies() {
  game.allyPaths = {}; // Clear paths

  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    if (ally.row < 0) continue; // Skip already removed

    const player = game.players[ally.type];

    // If reached player (adjacent), add HP
    if (distance(ally.row, ally.col, player.row, player.col) <= 1) {
      player.hp++;
      ally.row = -100; // Mark for removal
      continue;
    }

    // Use BFS to find optimal path - allies CAN'T break obstacles (false parameter)
    // If path is blocked by obstacles, ally won't move
    const path = findPath(ally.row, ally.col, player.row, player.col, false);
    if (path && path.length > 0) {
      const nextStep = path[0];

      // Check for enemy ally on next step - battle!
      const enemyAlly = findAlly(nextStep.row, nextStep.col);
      if (enemyAlly && enemyAlly.type !== ally.type) {
        // 50/50 random battle between allies
        if (Math.random() < 0.5) {
          // Current ally wins - enemy dies
          enemyAlly.row = -100;
        } else {
          // Enemy ally wins - current ally dies
          ally.row = -100;
        }
        continue;
      }

      // Check if next step is actually free (not blocked by own allies or obstacles)
      if (!enemyAlly && !findObstacle(nextStep.row, nextStep.col)) {
        // Store path for visualization
        game.allyPaths[i] = path;
        // Move to next step
        ally.row = nextStep.row;
        ally.col = nextStep.col;
      }
    }
  }

  // Remove dead/absorbed allies
  game.allies = game.allies.filter(a => a.row >= 0);
}

// BFS pathfinding for players - can walk through own allies, obstacles (break them)
function findPathForPlayer(fromR, fromC, toR, toC) {
  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, path: [] }];
  visited.add(`${fromR},${fromC}`);

  const directions = [
    { dr: -1, dc: 0 },  // up
    { dr: 1, dc: 0 },   // down
    { dr: 0, dc: -1 },  // left
    { dr: 0, dc: 1 }    // right
  ];

  while (queue.length > 0) {
    const current = queue.shift();

    // Found target
    if (current.r === toR && current.c === toC) {
      return current.path;
    }

    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const key = `${nr},${nc}`;

      if (visited.has(key)) continue;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      // Players can go through obstacles (they'll break them)
      // Players can go through allies (they'll kill enemy or absorb own)
      // Can't walk through enemy player (except as target for combat)
      const playerOnTile = findPlayer(nr, nc);
      if (playerOnTile && !(nr === toR && nc === toC)) continue;

      visited.add(key);
      const newPath = [...current.path, { row: nr, col: nc }];
      queue.push({ r: nr, c: nc, path: newPath });
    }
  }

  return null;
}

// BFS pathfinding for allies - can't break obstacles, avoids other allies
function findPath(fromR, fromC, toR, toC, allowObstacles = true) {
  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, path: [] }];
  visited.add(`${fromR},${fromC}`);

  const directions = [
    { dr: -1, dc: 0 },  // up
    { dr: 1, dc: 0 },   // down
    { dr: 0, dc: -1 },  // left
    { dr: 0, dc: 1 }    // right
  ];

  while (queue.length > 0) {
    const current = queue.shift();

    // Found target
    if (current.r === toR && current.c === toC) {
      return current.path;
    }

    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const key = `${nr},${nc}`;

      if (visited.has(key)) continue;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      // Allow obstacles if flag is set (player can break them)
      if (!allowObstacles && findObstacle(nr, nc)) continue;
      // Allies should avoid other allies (except target) to prevent blocking
      if (!allowObstacles && findAlly(nr, nc) && !(nr === toR && nc === toC)) continue;
      // Can't walk through players (except target)
      const playerOnTile = findPlayer(nr, nc);
      if (playerOnTile && !(nr === toR && nc === toC)) continue;
      
      visited.add(key);
      const newPath = [...current.path, { row: nr, col: nc }];
      queue.push({ r: nr, c: nc, path: newPath });
    }
  }
  
  return null; // No path found
}

// Get next step only (for compatibility)
function findNextStep(fromR, fromC, toR, toC) {
  const path = findPath(fromR, fromC, toR, toC);
  return path && path.length > 0 ? path[0] : null;
}

function gameWin(playerType) {
  game.gameOver = true;
  if (game.tickTimer) clearInterval(game.tickTimer);
  
  const emoji = playerType === 'duck' ? 'üê§' : 'üê∏';
  const name = playerType === 'duck' ? '–ö–∞—á–µ–Ω—è' : '–ñ–∞–±–∫–∞';
  const isHuman = playerType === game.humanPlayer;
  
  if (isHuman) {
    document.getElementById('winnerText').textContent = `üèÜ ${emoji} –ü–µ—Ä–µ–º–æ–≥–∞!`;
    document.getElementById('winnerDesc').textContent = `–¢–∏ –ø–µ—Ä–µ–º—ñ–≥! ${name} –¥–æ—Å—Ç–∞–≤–∏–≤ —Ç–æ—Ç–µ–º –∫–æ—Ä–æ–ª—é!`;
  } else {
    document.getElementById('winnerText').textContent = `üò¢ ${emoji} –ü—Ä–æ–≥—Ä–∞—à`;
    document.getElementById('winnerDesc').textContent = `AI –ø–µ—Ä–µ–º—ñ–≥. ${name} –¥–æ—Å—Ç–∞–≤–∏–≤ —Ç–æ—Ç–µ–º –∫–æ—Ä–æ–ª—é.`;
  }
  document.getElementById('winModal').classList.add('show');
}

function closeModal() {
  document.getElementById('winModal').classList.remove('show');
}

function resetGame() {
  closeModal();
  if (game.tickTimer) clearInterval(game.tickTimer);
  
  // Reset AI indicator
  document.querySelectorAll('.player-info').forEach(el => el.classList.remove('ai'));
  
  // Show character selection
  document.getElementById('selectModal').classList.add('show');
  
  initGame();
}

// ============ START ============
function selectCharacter(character) {
  game.humanPlayer = character;
  game.aiPlayer = character === 'duck' ? 'frog' : 'duck';
  game.gameStarted = true;

  // Show game screen
  showScreen('gameScreen');

  // Start the game tick
  startGameTick();

  render();
  updateHUD();
}

function startGameTick() {
  if (game.tickTimer) clearInterval(game.tickTimer);
  if (game.tickProgressTimer) cancelAnimationFrame(game.tickProgressTimer);

  const RING_CIRCUMFERENCE = 97.39; // 2 * PI * 15.5
  const tickRing = document.getElementById('tickRing');

  // Reset ring progress
  tickRing.style.strokeDashoffset = RING_CIRCUMFERENCE;

  // Start tick timer
  game.tickStartTime = performance.now();

  game.tickTimer = setInterval(() => {
    if (!game.gameOver && game.gameStarted) {
      gameTick();
      // Reset progress after tick
      game.tickStartTime = performance.now();
      tickRing.style.transition = 'none';
      tickRing.style.strokeDashoffset = RING_CIRCUMFERENCE;
      // Re-enable transition after reflow
      requestAnimationFrame(() => {
        tickRing.style.transition = 'stroke-dashoffset 0.05s linear';
      });
    }
  }, TICK_MS);

  // Start progress animation
  updateTickProgress();
}

function updateTickProgress() {
  if (game.gameOver || !game.gameStarted) return;

  const RING_CIRCUMFERENCE = 97.39;
  const tickRing = document.getElementById('tickRing');
  const elapsed = performance.now() - game.tickStartTime;
  const progress = Math.min(elapsed / TICK_MS, 1);

  // Ring fills clockwise (offset decreases from full to 0)
  tickRing.style.strokeDashoffset = RING_CIRCUMFERENCE * (1 - progress);

  game.tickProgressTimer = requestAnimationFrame(updateTickProgress);
}

function gameTick() {
  game.tick++;
  
  // Spawn allies every 4 ticks
  if (game.tick % ALLY_SPAWN_TICKS === 0) {
    spawnAlly('duck');
    spawnAlly('frog');
  }
  
  // Move allies
  moveAllies();
  
  // Move human player one step if has path
  if (game.humanPlayer) {
    movePlayerOneStep(game.humanPlayer);
  }
  
  // AI makes one step
  aiMove();
  
  render();
  updateHUD();
}

// Move player one step along their path
function movePlayerOneStep(playerType) {
  const player = game.players[playerType];
  
  if (!player.targetPath || player.targetPath.length === 0) return;
  
  const nextStep = player.targetPath[0];
  
  // Check what's on next step
  const obstacle = findObstacle(nextStep.row, nextStep.col);
  const enemyType = findPlayer(nextStep.row, nextStep.col);
  const ally = findAlly(nextStep.row, nextStep.col);
  
  // Attack enemy player
  if (enemyType && enemyType !== playerType) {
    combat(playerType, enemyType);
    player.targetPath = []; // Clear path after combat
    return;
  }
  
  // Attack enemy ally (costs 1 HP)
  if (ally && ally.type !== playerType) {
    if (player.hp > 1) {
      player.hp--;
      // Add death animation to ally tile
      const allyTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (allyTile) {
        allyTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites();
      setTimeout(() => {
        game.allies = game.allies.filter(a => a !== ally);
        render();
      }, 250);
    }
    player.targetPath = []; // Clear path after action
    return;
  }

  // Absorb own ally (gains 1 HP, moves through them)
  if (ally && ally.type === playerType) {
    player.hp++;
    game.allies = game.allies.filter(a => a !== ally);
    // Continue moving - don't return, let the move happen below
  }
  
  // Break obstacle
  if (obstacle) {
    if (player.hp > 1) {
      player.hp--;
      // Add breaking animation
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites(); // Update sprite HP badge
      // Remove obstacle after animation
      setTimeout(() => {
        game.obstacles = game.obstacles.filter(o => o !== obstacle);
        render();
      }, 250);
    } else {
      // Show can't break feedback
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('cant-break');
        setTimeout(() => obstacleTile.classList.remove('cant-break'), 300);
      }
    }
    player.targetPath = []; // Clear path after action
    return;
  }
  
  // Check if tile is blocked by something else (obstacles handled above, allies handled above)
  // Only check for out of bounds, kings, and other players
  if (nextStep.row < 0 || nextStep.row >= ROWS || nextStep.col < 0 || nextStep.col >= COLS) {
    player.targetPath = [];
    return;
  }
  if (isKingTile(nextStep.row, nextStep.col)) {
    player.targetPath = [];
    return;
  }
  // If there's still an obstacle (player couldn't break it), stop
  if (findObstacle(nextStep.row, nextStep.col)) {
    player.targetPath = [];
    return;
  }

  // Move player
  player.row = nextStep.row;
  player.col = nextStep.col;
  player.targetPath.shift(); // Remove completed step
  
  // Pick up totem
  const totemKey = findTotem(player.row, player.col);
  if (totemKey) {
    const totem = game.totems[totemKey];
    if (totem.owner === playerType && !totem.pickedBy) {
      totem.pickedBy = playerType;
      player.hasTotem = true;
      totem.row = -1;
      totem.col = -1;
    }
  }
  
  // Check win condition
  if (player.hasTotem) {
    const zone = isKingZone(player.row, player.col);
    if (zone === playerType) {
      gameWin(playerType);
    }
  }
}

// ============ AI LOGIC ============

// AI Tactics enum
const AI_TACTICS = {
  GET_TOTEM: 'get_totem',       // –ô—Ç–∏ –∑–∞ —Ç–æ—Ç–µ–º–æ–º
  RETURN_TOTEM: 'return_totem', // –ù–µ—Å—Ç–∏ —Ç–æ—Ç–µ–º –¥–æ –±–∞–∑–∏
  INTERCEPT: 'intercept',       // –ü–µ—Ä–µ—Ö–æ–ø–∏—Ç–∏ –≤–æ—Ä–æ–≥–∞ –∑ —Ç–æ—Ç–µ–º–æ–º
  COLLECT_ALLIES: 'collect',    // –ó–±–∏—Ä–∞—Ç–∏ —Å–æ—é–∑–Ω–∏–∫—ñ–≤ –¥–ª—è HP
  ATTACK: 'attack',             // –ê—Ç–∞–∫—É–≤–∞—Ç–∏ –≤–æ—Ä–æ–≥–∞
  AVOID: 'avoid'                // –£–Ω–∏–∫–∞—Ç–∏ –±–æ—é (—è–∫—â–æ —Å–ª–∞–±—à–∏–π)
};

function aiMove() {
  if (!game.aiPlayer || game.gameOver) return;

  const ai = game.players[game.aiPlayer];

  // AI –ø–µ—Ä–µ–æ—Ü—ñ–Ω—é—î —Ç–∞–∫—Ç–∏–∫—É –∫–æ–∂–µ–Ω —Ç—ñ–∫
  const tactic = evaluateAITactic();

  // –ü–ª–∞–Ω—É—î–º–æ —à–ª—è—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ —Ç–∞–∫—Ç–∏–∫–∏
  planAIPath(tactic);

  // –í–∏–∫–æ–Ω—É—î–º–æ –æ–¥–∏–Ω –∫—Ä–æ–∫
  movePlayerOneStep(game.aiPlayer);
}

function evaluateAITactic() {
  const ai = game.players[game.aiPlayer];
  const human = game.players[game.humanPlayer];
  const aiTotemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
  const humanTotemKey = game.humanPlayer === 'duck' ? 'duck' : 'snake';
  const aiTotem = game.totems[aiTotemKey];
  const humanTotem = game.totems[humanTotemKey];

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 1: –Ø–∫—â–æ AI –º–∞—î —Ç–æ—Ç–µ–º - –Ω–µ—Å—Ç–∏ –¥–æ –±–∞–∑–∏
  if (ai.hasTotem) {
    return AI_TACTICS.RETURN_TOTEM;
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 2: –Ø–∫—â–æ –≤–æ—Ä–æ–≥ –º–∞—î —Ç–æ—Ç–µ–º —ñ AI —Å–∏–ª—å–Ω—ñ—à–∏–π - –ø–µ—Ä–µ—Ö–æ–ø–ª—é–≤–∞—Ç–∏
  if (human.hasTotem && ai.hp >= human.hp) {
    const distToHuman = distance(ai.row, ai.col, human.row, human.col);
    if (distToHuman <= 6) {
      return AI_TACTICS.INTERCEPT;
    }
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 3: –Ø–∫—â–æ HP –Ω–∏–∑—å–∫–∏–π —ñ —î —Å–æ—é–∑–Ω–∏–∫–∏ –ø–æ—Ä—É—á - –∑–±–∏—Ä–∞—Ç–∏
  if (ai.hp <= 2) {
    const nearbyAlly = findNearestAlly(game.aiPlayer, ai.row, ai.col);
    if (nearbyAlly && distance(ai.row, ai.col, nearbyAlly.row, nearbyAlly.col) <= 3) {
      return AI_TACTICS.COLLECT_ALLIES;
    }
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 4: –Ø–∫—â–æ —Ç–æ—Ç–µ–º –¥–æ—Å—Ç—É–ø–Ω–∏–π - –π—Ç–∏ –∑–∞ –Ω–∏–º
  if (aiTotem.pickedBy === null) {
    return AI_TACTICS.GET_TOTEM;
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 5: –Ø–∫—â–æ AI —Å–∏–ª—å–Ω—ñ—à–∏–π - –∞—Ç–∞–∫—É–≤–∞—Ç–∏
  if (ai.hp > human.hp + 1) {
    return AI_TACTICS.ATTACK;
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 6: –ó–±–∏—Ä–∞—Ç–∏ —Å–æ—é–∑–Ω–∏–∫—ñ–≤ –¥–ª—è –ø–æ—Å–∏–ª–µ–Ω–Ω—è
  return AI_TACTICS.COLLECT_ALLIES;
}

function planAIPath(tactic) {
  const ai = game.players[game.aiPlayer];
  const human = game.players[game.humanPlayer];

  let targetR, targetC;
  let avoidObstacles = false;

  switch (tactic) {
    case AI_TACTICS.RETURN_TOTEM: {
      // –ù–µ—Å—Ç–∏ —Ç–æ—Ç–µ–º - –∑–Ω–∞–π—Ç–∏ –Ω–∞–π–∫—Ä–∞—â–∏–π —à–ª—è—Ö –¥–æ king zone
      const kingZone = findBestKingZone(game.aiPlayer, ai.row, ai.col, human);
      if (kingZone) {
        targetR = kingZone.row;
        targetC = kingZone.col;
        avoidObstacles = true; // –£–Ω–∏–∫–∞—Ç–∏ –ø–µ—Ä–µ—à–∫–æ–¥ —â–æ–± –Ω–µ –≤–∏—Ç—Ä–∞—á–∞—Ç–∏ HP
      }
      break;
    }

    case AI_TACTICS.INTERCEPT: {
      // –ü–µ—Ä–µ—Ö–æ–ø–∏—Ç–∏ –≤–æ—Ä–æ–≥–∞ - –ø–µ—Ä–µ–¥–±–∞—á–∏—Ç–∏ –∫—É–¥–∏ –≤—ñ–Ω —Ä—É—Ö–∞—î—Ç—å—Å—è
      const interceptPoint = predictInterceptPoint(human);
      if (interceptPoint) {
        targetR = interceptPoint.row;
        targetC = interceptPoint.col;
      } else {
        targetR = human.row;
        targetC = human.col;
      }
      break;
    }

    case AI_TACTICS.COLLECT_ALLIES: {
      // –ó–Ω–∞–π—Ç–∏ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ —Å–æ—é–∑–Ω–∏–∫–∞
      const ally = findNearestAlly(game.aiPlayer, ai.row, ai.col);
      if (ally) {
        targetR = ally.row;
        targetC = ally.col;
        avoidObstacles = true;
      } else {
        // –Ø–∫—â–æ –Ω–µ–º–∞—î —Å–æ—é–∑–Ω–∏–∫—ñ–≤ - –π—Ç–∏ –∑–∞ —Ç–æ—Ç–µ–º–æ–º –∞–±–æ –¥–æ —Ü–µ–Ω—Ç—Ä—É
        const totemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
        const totem = game.totems[totemKey];
        if (totem.pickedBy === null) {
          targetR = totem.row;
          targetC = totem.col;
        }
      }
      break;
    }

    case AI_TACTICS.GET_TOTEM: {
      const totemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
      const totem = game.totems[totemKey];
      if (totem.pickedBy === null) {
        targetR = totem.row;
        targetC = totem.col;
        // –Ø–∫—â–æ –≤–æ—Ä–æ–≥ –±–ª–∏–∂—á–µ –¥–æ —Ç–æ—Ç–µ–º—É - –π—Ç–∏ –∞–≥—Ä–µ—Å–∏–≤–Ω—ñ—à–µ (—á–µ—Ä–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥–∏)
        const aiDistToTotem = distance(ai.row, ai.col, totem.row, totem.col);
        const humanDistToTotem = distance(human.row, human.col, totem.row, totem.col);
        avoidObstacles = aiDistToTotem < humanDistToTotem;
      }
      break;
    }

    case AI_TACTICS.ATTACK: {
      targetR = human.row;
      targetC = human.col;
      break;
    }

    case AI_TACTICS.AVOID: {
      // –ó–Ω–∞–π—Ç–∏ –±–µ–∑–ø–µ—á–Ω—É –ø–æ–∑–∏—Ü—ñ—é –ø–æ–¥–∞–ª—ñ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞
      const safeSpot = findSafeSpot(ai, human);
      if (safeSpot) {
        targetR = safeSpot.row;
        targetC = safeSpot.col;
        avoidObstacles = true;
      }
      break;
    }
  }

  if (targetR === undefined) return;

  // –ó–Ω–∞–π—Ç–∏ —à–ª—è—Ö
  let fullPath;
  if (avoidObstacles) {
    // –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —à–ª—è—Ö –±–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥
    fullPath = findPath(ai.row, ai.col, targetR, targetC, false);
    if (!fullPath || fullPath.length === 0) {
      fullPath = findPathForPlayer(ai.row, ai.col, targetR, targetC);
    }
  } else {
    fullPath = findPathForPlayer(ai.row, ai.col, targetR, targetC);
  }

  if (fullPath && fullPath.length > 0) {
    // AI –ø–ª–∞–Ω—É—î –Ω–∞ 1-2 –∫—Ä–æ–∫–∏ –≤–ø–µ—Ä–µ–¥
    ai.targetPath = fullPath.slice(0, 2);
  }
}

function findNearestAlly(playerType, fromR, fromC) {
  let nearest = null;
  let minDist = Infinity;

  for (const ally of game.allies) {
    if (ally.type === playerType && ally.row >= 0) {
      const d = distance(fromR, fromC, ally.row, ally.col);
      if (d < minDist) {
        minDist = d;
        nearest = ally;
      }
    }
  }

  return nearest;
}

function findBestKingZone(playerType, fromR, fromC, enemy) {
  // –ó–Ω–∞–π—Ç–∏ king zone –∫–ª—ñ—Ç–∏–Ω–∫—É —è–∫–∞ –Ω–∞–π–¥–∞–ª—ñ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞ –∞–ª–µ –±–ª–∏–∑—å–∫–æ –¥–æ AI
  let best = null;
  let bestScore = -Infinity;

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === playerType && !isTileBlocked(r, c)) {
        const distFromAI = distance(fromR, fromC, r, c);
        const distFromEnemy = distance(enemy.row, enemy.col, r, c);
        // Score: –±–ª–∏–∑—å–∫–æ –¥–æ AI + –¥–∞–ª–µ–∫–æ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞
        const score = distFromEnemy * 2 - distFromAI;
        if (score > bestScore) {
          bestScore = score;
          best = { row: r, col: c };
        }
      }
    }
  }

  return best;
}

function predictInterceptPoint(target) {
  // –ü–µ—Ä–µ–¥–±–∞—á–∏—Ç–∏ –∫—É–¥–∏ —Ä—É—Ö–∞—î—Ç—å—Å—è –≤–æ—Ä–æ–≥
  if (target.targetPath && target.targetPath.length > 0) {
    // –í–æ—Ä–æ–≥ –º–∞—î –º–∞—Ä—à—Ä—É—Ç - –ø–µ—Ä–µ—Ö–æ–ø–∏—Ç–∏ –Ω–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π —Ç–æ—á—Ü—ñ
    const lastPoint = target.targetPath[target.targetPath.length - 1];
    return { row: lastPoint.row, col: lastPoint.col };
  }

  // –Ø–∫—â–æ –≤–æ—Ä–æ–≥ –Ω–µ—Å–µ —Ç–æ—Ç–µ–º - –≤—ñ–Ω —ñ–¥–µ –¥–æ —Å–≤–æ—î—ó –±–∞–∑–∏
  if (target.hasTotem) {
    const enemyType = target === game.players.duck ? 'duck' : 'frog';
    return findNearestKingZone(enemyType, target.row, target.col);
  }

  return null;
}

function findSafeSpot(ai, enemy) {
  // –ó–Ω–∞–π—Ç–∏ –∫–ª—ñ—Ç–∏–Ω–∫—É –ø–æ–¥–∞–ª—ñ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞
  let best = null;
  let maxDist = 0;

  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –≤ —Ä–∞–¥—ñ—É—Å—ñ 3
  for (let dr = -3; dr <= 3; dr++) {
    for (let dc = -3; dc <= 3; dc++) {
      const r = ai.row + dr;
      const c = ai.col + dc;

      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) continue;
      if (isKingTile(r, c)) continue;
      if (findObstacle(r, c)) continue;
      if (findPlayer(r, c)) continue;

      const distFromEnemy = distance(r, c, enemy.row, enemy.col);
      if (distFromEnemy > maxDist) {
        maxDist = distFromEnemy;
        best = { row: r, col: c };
      }
    }
  }

  return best;
}

function findNearestKingZone(playerType, fromR, fromC) {
  let nearest = null;
  let minDist = Infinity;

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === playerType && !isTileBlocked(r, c)) {
        const d = distance(fromR, fromC, r, c);
        if (d < minDist) {
          minDist = d;
          nearest = { row: r, col: c };
        }
      }
    }
  }

  return nearest;
}

// ============ SETTINGS ============
let settings = {
  vibration: true,
  sound: false
};

function loadSettings() {
  try {
    const saved = localStorage.getItem('duckVsFrogSettings');
    if (saved) {
      settings = { ...settings, ...JSON.parse(saved) };
      updateSettingsUI();
    }
  } catch (e) {}
}

function saveSettings() {
  try {
    localStorage.setItem('duckVsFrogSettings', JSON.stringify(settings));
  } catch (e) {}
}

function updateSettingsUI() {
  // Toggles
  document.getElementById('vibrationToggle').classList.toggle('on', settings.vibration);
  document.getElementById('soundToggle').classList.toggle('on', settings.sound);
}

function toggleVibration() {
  settings.vibration = !settings.vibration;
  saveSettings();
  updateSettingsUI();
  if (settings.vibration && navigator.vibrate) {
    navigator.vibrate(50);
  }
}

function toggleSound() {
  settings.sound = !settings.sound;
  saveSettings();
  updateSettingsUI();
}

// ============ SCREEN NAVIGATION ============
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(screenId).classList.add('active');
}

// ============ TUTORIAL ============
let currentSlide = 0;
const totalSlides = 4;

function goToSlide(index) {
  currentSlide = index;
  document.querySelectorAll('.tutorial-slide').forEach((slide, i) => {
    slide.classList.toggle('active', i === index);
  });
  document.querySelectorAll('.tutorial-dot').forEach((dot, i) => {
    dot.classList.toggle('active', i === index);
  });
  // Update buttons
  document.getElementById('tutorialPrev').style.visibility = index === 0 ? 'hidden' : 'visible';
  document.getElementById('tutorialNext').textContent = index === totalSlides - 1 ? '–ì–æ—Ç–æ–≤–æ ‚úì' : '–î–∞–ª—ñ ‚Üí';
}

function nextSlide() {
  if (currentSlide < totalSlides - 1) {
    goToSlide(currentSlide + 1);
  } else {
    showScreen('menuScreen');
    goToSlide(0);
  }
}

function prevSlide() {
  if (currentSlide > 0) {
    goToSlide(currentSlide - 1);
  }
}

// ============ GAME CONTROLS ============
function pauseGame() {
  if (game.tickTimer) {
    clearInterval(game.tickTimer);
    game.tickTimer = null;
  }
  if (game.tickProgressTimer) {
    cancelAnimationFrame(game.tickProgressTimer);
    game.tickProgressTimer = null;
  }
  document.getElementById('pauseModal').classList.add('show');
}

function resumeGame() {
  document.getElementById('pauseModal').classList.remove('show');
  startGameTick();
}

function goToMenu() {
  if (game.tickTimer) {
    clearInterval(game.tickTimer);
    game.tickTimer = null;
  }
  if (game.tickProgressTimer) {
    cancelAnimationFrame(game.tickProgressTimer);
    game.tickProgressTimer = null;
  }
  document.getElementById('pauseModal').classList.remove('show');
  document.getElementById('winModal').classList.remove('show');
  showScreen('menuScreen');
  initGame();
}

function vibrate(pattern) {
  if (settings.vibration && navigator.vibrate) {
    navigator.vibrate(pattern);
  }
}

// ============ INIT ============
loadSettings();
initGame();

// Event delegation for board clicks - –∑–∞–≤–∂–¥–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –¥–ª—è –Ω–∞–¥—ñ–π–Ω–æ—Å—Ç—ñ
document.getElementById('board').addEventListener('click', (e) => {
  const board = document.getElementById('board');
  const boardRect = board.getBoundingClientRect();
  const padding = 8; // board padding

  // –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –ø–æ–∑–∏—Ü—ñ—é –∫–ª—ñ–∫—É –≤—ñ–¥–Ω–æ—Å–Ω–æ –¥–æ—à–∫–∏
  const x = e.clientX - boardRect.left - padding;
  const y = e.clientY - boardRect.top - padding;

  // –†–æ–∑–º—ñ—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏ –∑ gap
  const cellWidth = (boardRect.width - padding * 2) / COLS;
  const cellHeight = (boardRect.height - padding * 2) / ROWS;

  // –í–∏–∑–Ω–∞—á–∞—î–º–æ row —ñ col
  const col = Math.floor(x / cellWidth);
  const row = Math.floor(y / cellHeight);

  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ–∂—ñ
  if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
    handleTileClick(row, col);
  }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (game.tickTimer) clearInterval(game.tickTimer);
});
</script>
</body>
</html>
