<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>üê§ vs üê∏</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #e0e5ec;
      --shadow-d: #a3b1c6;
      --shadow-l: #ffffff;
      --duck-color: rgba(247, 220, 111, 0.4);
      --frog-color: rgba(139, 195, 74, 0.4);
      --divider-color: rgba(120, 130, 150, 0.3);
    }
    html, body { 
      height: 100%; 
      overflow: hidden;
      touch-action: manipulation;
    }
    body {
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', system-ui, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 10px;
    }

    /* HUD */
    .hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 320px;
      margin-bottom: 10px;
      gap: 10px;
    }
    .player-info {
      flex: 1;
      padding: 10px 15px;
      border-radius: 16px;
      background: var(--bg);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .player-info.duck { border: 2px solid var(--duck-color); }
    .player-info.frog { border: 2px solid var(--frog-color); }
    .player-icon { font-size: 1.5rem; }
    .player-hp {
      font-size: 1.2rem;
      font-weight: 700;
      color: #e74c3c;
    }
    .player-totem {
      font-size: 0.9rem;
      opacity: 0.7;
    }

    /* Board */
    .board-container {
      position: relative;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(15, 1fr);
      gap: 3px;
      width: min(calc(100vw - 20px), 300px);
      aspect-ratio: 9 / 15;
      padding: 8px;
      border-radius: 16px;
      background: var(--bg);
      box-shadow:
        8px 8px 16px var(--shadow-d),
        -8px -8px 16px var(--shadow-l);
      position: relative;
      z-index: 1;
    }

    /* Tiles */
    .tile {
      border-radius: 6px;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      cursor: pointer;
      position: relative;
      box-shadow:
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l);
      transition: transform 0.1s, box-shadow 0.1s;
      border: 2px solid transparent;
    }
    .tile:active {
      transform: scale(0.95);
      box-shadow: 
        inset 2px 2px 4px var(--shadow-d),
        inset -2px -2px 4px var(--shadow-l);
    }
    
    /* Divider diagonal - tiles on the diagonal line */
    .tile.divider {
      border: 2px solid rgba(120, 130, 150, 0.5);
    }

    /* King zones */
    .tile.duck-zone {
      border-color: var(--duck-color);
    }
    .tile.frog-zone {
      border-color: var(--frog-color);
    }

    /* Kings */
    .tile.king {
      grid-column: span 2;
      grid-row: span 2;
      font-size: 2rem;
      cursor: default;
      border-radius: 10px;
      box-shadow: 
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .tile.duck-king {
      grid-column: 8 / 10;
      grid-row: 1 / 3;
      border: 3px solid var(--duck-color);
      background-image: url('duck-king.png');
      background-size: 85%;
      background-position: center;
      background-repeat: no-repeat;
    }
    .tile.frog-king {
      grid-column: 1 / 3;
      grid-row: 14 / 16;
      border: 3px solid var(--frog-color);
      background-image: url('frog-king.png');
      background-size: 85%;
      background-position: center;
      background-repeat: no-repeat;
    }

    /* Game objects */
    .tile.obstacle {
      background-color: rgba(200, 200, 200, 0.3);
      background-size: 95%;
      background-position: center;
      background-repeat: no-repeat;
    }
    .tile.obstacle.wave {
      background-image: url('duck-obstacle.png');
    }
    .tile.obstacle.bush {
      background-image: url('frog-obstacle.png');
    }
    .tile.obstacle.breaking {
      animation: obstacle-break 0.3s ease-out;
    }
    @keyframes obstacle-break {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.5; }
      100% { transform: scale(0); opacity: 0; }
    }
    .tile.obstacle.cant-break {
      animation: obstacle-shake 0.3s ease-out;
    }
    @keyframes obstacle-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }
    
    .tile.player {
      z-index: 10;
      box-shadow: 
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    
    /* Animated player sprites */
    .player-sprite {
      position: absolute;
      border-radius: 6px;
      background: var(--bg);
      background-size: 90%;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 20;
      pointer-events: none;
      transition: left 0.3s ease-out, top 0.3s ease-out;
      box-shadow:
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l),
        0 0 0 2px rgba(100, 150, 255, 0.5);
    }
    #duckSprite {
      background-image: url('duck-player.png');
    }
    #frogSprite {
      background-image: url('frog-player.png');
    }
    .player-sprite .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .player-sprite .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      width: 18px;
      height: 18px;
      background: white;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      border-radius: 50%;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    .player-sprite .totem-indicator.duck-totem-ind {
      background-image: url('duck-totem.png');
    }
    .player-sprite .totem-indicator.frog-totem-ind {
      background-image: url('frog-totem.png');
    }
    
    .tile.ally {
      font-size: 0.7rem;
      opacity: 0.8;
    }
    .tile.ally.breaking {
      animation: obstacle-break 0.3s ease-out;
    }

    /* Animated ally sprites */
    .ally-sprite {
      position: absolute;
      border-radius: 5px;
      background: var(--bg);
      background-size: 90%;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 15;
      pointer-events: none;
      transition: left 0.3s ease-out, top 0.3s ease-out, opacity 0.2s;
      box-shadow:
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l);
    }
    .ally-sprite.duck-ally {
      background-image: url('duck-player.png');
      border: 1px solid var(--duck-color);
    }
    .ally-sprite.frog-ally {
      background-image: url('frog-player.png');
      border: 1px solid var(--frog-color);
    }
    .ally-sprite.dying {
      opacity: 0;
      transform: scale(0.5);
    }
    
    /* Path visualization for allies */
    .tile.ally-path-duck::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(247, 220, 111, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    .tile.ally-path-frog::before {
      content: '';
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(139, 195, 74, 0.6);
      border-radius: 50%;
      z-index: 1;
    }
    
    /* Player target path visualization */
    .tile.player-path {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        inset 0 0 8px rgba(100, 150, 255, 0.4);
    }
    /* Totem sprites - similar to player sprites but smaller */
    .totem-sprite {
      position: absolute;
      border-radius: 5px;
      background: var(--bg);
      background-size: 90%;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 18;
      pointer-events: none;
    }
    .totem-sprite.snake-totem {
      background-image: url('frog-totem.png');
      border: 2px solid var(--frog-color);
      box-shadow:
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        0 0 0 2px rgba(46, 204, 113, 0.5);
      animation: totem-pulse-frog 2s ease-in-out infinite;
    }
    .totem-sprite.duck-totem {
      background-image: url('duck-totem.png');
      border: 2px solid var(--duck-color);
      box-shadow:
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        0 0 0 2px rgba(52, 152, 219, 0.5);
      animation: totem-pulse-duck 2s ease-in-out infinite;
    }
    .totem-sprite.hidden {
      display: none;
    }
    @keyframes totem-pulse-frog {
      0%, 100% {
        box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l), 0 0 0 2px rgba(46, 204, 113, 0.5);
      }
      50% {
        box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l), 0 0 8px rgba(46, 204, 113, 0.7), 0 0 0 2px rgba(46, 204, 113, 0.7);
      }
    }
    @keyframes totem-pulse-duck {
      0%, 100% {
        box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l), 0 0 0 2px rgba(52, 152, 219, 0.5);
      }
      50% {
        box-shadow: 2px 2px 4px var(--shadow-d), -2px -2px 4px var(--shadow-l), 0 0 8px rgba(52, 152, 219, 0.7), 0 0 0 2px rgba(52, 152, 219, 0.7);
      }
    }

    /* Highlight for valid moves */
    .tile.highlight {
      box-shadow: 
        2px 2px 4px var(--shadow-d),
        -2px -2px 4px var(--shadow-l),
        0 0 0 3px rgba(100, 200, 100, 0.5);
    }

    /* Totem indicator on player */
    .totem-indicator {
      position: absolute;
      top: -5px;
      right: -5px;
      font-size: 0.6rem;
      background: white;
      border-radius: 50%;
      padding: 2px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    /* HP badge on player */
    .hp-badge {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 0.55rem;
      font-weight: 700;
      background: #e74c3c;
      color: white;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    /* Controls */
    .controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
    }
    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: #333;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
    }
    .btn:active {
      box-shadow: 
        inset 3px 3px 6px var(--shadow-d),
        inset -3px -3px 6px var(--shadow-l);
    }

    /* Turn indicator */
    .turn-info {
      margin-top: 10px;
      font-size: 0.8rem;
      color: #666;
      text-align: center;
    }

    /* Winner modal */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: var(--bg);
      padding: 30px 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow:
        10px 10px 20px var(--shadow-d),
        -10px -10px 20px var(--shadow-l);
    }
    .modal-content h2 {
      font-size: 2rem;
      margin-bottom: 10px;
    }
    .modal-content p {
      font-size: 1rem;
      color: #666;
      margin-bottom: 20px;
    }
    
    /* Character selection */
    .select-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
    }
    .select-btn {
      padding: 25px 35px;
      border: none;
      border-radius: 16px;
      background: var(--bg);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      transition: all 0.2s;
    }
    .select-btn:hover {
      transform: scale(1.05);
    }
    .select-btn:active {
      box-shadow:
        inset 4px 4px 8px var(--shadow-d),
        inset -4px -4px 8px var(--shadow-l);
    }
    .select-btn.duck-select:hover {
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--duck-color);
    }
    .select-btn.frog-select:hover {
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l),
        0 0 0 3px var(--frog-color);
    }
    .select-icon {
      width: min(120px, 20vh);
      height: min(120px, 20vh);
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
    }
    .duck-select .select-icon {
      background-image: url('duck-king.png');
    }
    .frog-select .select-icon {
      background-image: url('frog-king.png');
    }
    .select-name {
      font-size: clamp(0.9rem, 2vh, 1.1rem);
      font-weight: 600;
      color: #333;
    }
    .select-btn {
      padding: clamp(12px, 3vh, 25px) clamp(20px, 4vh, 35px);
    }
    .char-select-title {
      font-size: clamp(1rem, 3vh, 1.4rem);
      margin-top: clamp(10px, 2vh, 20px);
    }

    /* Mobile adaptation for character select */
    @media (max-width: 360px) {
      .select-buttons {
        gap: 12px;
      }
      .select-icon {
        width: min(90px, 18vh);
        height: min(90px, 18vh);
      }
    }

    /* AI indicator */
    .player-info.ai::after {
      content: 'ü§ñ';
      margin-left: 5px;
    }

    /* ============ SCREENS ============ */
    .screen {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--bg);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 50;
      overflow-y: auto;
    }
    .screen.active { display: flex; }

    /* Select screen specific - ensure content fits */
    #selectScreen {
      justify-content: safe center;
      padding-top: 40px;
      padding-bottom: 40px;
    }

    /* Main Menu */
    .menu-logo {
      width: 260px;
      height: auto;
      margin-bottom: 20px;
      border-radius: 20px;
      background: var(--bg);
      padding: 15px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
    }
    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 100%;
      max-width: 250px;
    }
    .menu-btn {
      padding: 18px 30px;
      border: none;
      border-radius: 16px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: #333;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
      transition: all 0.2s;
    }
    .menu-btn:active {
      box-shadow:
        inset 4px 4px 8px var(--shadow-d),
        inset -4px -4px 8px var(--shadow-l);
    }
    .menu-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    /* Settings Screen */
    .settings-container {
      width: 100%;
      max-width: 340px;
      text-align: left;
    }
    .settings-title {
      font-size: 1.4rem;
      margin-bottom: 16px;
      text-align: center;
    }
    .settings-content {
      background: var(--bg);
      padding: 20px;
      border-radius: 16px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
    }
    .setting-item {
      padding: 12px 0;
      border-bottom: 1px solid rgba(0,0,0,0.05);
    }
    .setting-item:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }
    .setting-item:first-child {
      padding-top: 0;
    }
    .setting-label {
      font-size: 0.95rem;
      color: #444;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .setting-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .toggle-switch {
      width: 50px;
      height: 28px;
      background: var(--shadow-d);
      border-radius: 14px;
      position: relative;
      cursor: pointer;
      transition: background 0.3s;
      box-shadow: inset 2px 2px 4px rgba(0,0,0,0.1);
    }
    .toggle-switch.on {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: left 0.3s;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }
    .toggle-switch.on::after {
      left: 25px;
    }
    .back-btn {
      margin-top: 20px;
    }

    /* Tutorial Screen */
    .tutorial-container {
      width: 100%;
      max-width: 340px;
      text-align: left;
      max-height: 80vh;
      overflow-y: auto;
    }
    .tutorial-title {
      font-size: 1.4rem;
      margin-bottom: 16px;
      text-align: center;
    }
    .tutorial-content {
      background: var(--bg);
      padding: 20px;
      border-radius: 16px;
      box-shadow:
        6px 6px 12px var(--shadow-d),
        -6px -6px 12px var(--shadow-l);
    }
    .tutorial-section {
      margin-bottom: 16px;
    }
    .tutorial-section:last-child {
      margin-bottom: 0;
    }
    .tutorial-section h3 {
      font-size: 1rem;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .tutorial-section p {
      font-size: 0.85rem;
      color: #555;
      line-height: 1.5;
      margin: 0;
    }
    .tutorial-section ul {
      font-size: 0.85rem;
      color: #555;
      line-height: 1.6;
      margin: 0;
      padding-left: 20px;
    }

    /* Game Screen - –≤—Å–µ —â—ñ–ª—å–Ω–æ –æ–¥–∏–Ω –ø—ñ–¥ –æ–¥–Ω–∏–º */
    #gameScreen {
      padding: 8px 0;
      justify-content: flex-start;
      gap: 8px;
    }
    .match-score-bar {
      flex-shrink: 0;
    }
    .game-top {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .game-bottom {
      flex-shrink: 0;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .game-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      padding: 10px 20px;
      background: var(--bg);
      box-shadow: inset 0 4px 6px -4px var(--shadow-d);
    }
    .panel-btn {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 12px;
      font-size: 1.2rem;
      cursor: pointer;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        4px 4px 8px var(--shadow-d),
        -4px -4px 8px var(--shadow-l);
      transition: all 0.15s;
      background-size: 85%;
      background-position: center;
      background-repeat: no-repeat;
    }
    .panel-btn:active {
      box-shadow:
        inset 3px 3px 6px var(--shadow-d),
        inset -3px -3px 6px var(--shadow-l);
    }
    .btn-pause { background-image: url('button-pause.png'); }
    .btn-home { background-image: url('button-home.png'); }
    .btn-play { background-image: url('button-play.png'); }
    .btn-menu { background-image: url('button-menu.png'); }

    /* Circular tick progress */
    .tick-ring-container {
      position: relative;
      width: 50px;
      height: 50px;
    }
    .tick-ring {
      width: 50px;
      height: 50px;
      transform: rotate(-90deg);
    }
    .tick-ring-bg {
      fill: none;
      stroke: var(--shadow-d);
      stroke-width: 3;
    }
    .tick-ring-progress {
      fill: none;
      stroke: url(#tickGradient);
      stroke-width: 3;
      stroke-linecap: round;
      stroke-dasharray: 97.39; /* 2 * PI * 15.5 */
      stroke-dashoffset: 97.39;
      transition: stroke-dashoffset 0.05s linear;
    }
    .tick-number {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.9rem;
      font-weight: 700;
      color: #555;
    }

    /* Character Select Screen */
    .select-container {
      width: 100%;
      max-width: 340px;
      text-align: center;
    }
    .char-select-title {
      font-size: 1.4rem;
      margin-top: 20px;
      margin-bottom: 0;
    }

    /* Match Score Bar - —Ç–æ–Ω–∫–∏–π —Ä—è–¥–æ–∫ –Ω–∞–¥ –ø–æ–ª–µ–º */
    .match-score-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 6px 16px;
      background: var(--bg);
      box-shadow:
        0 2px 4px var(--shadow-d);
    }
    .score-duck, .score-frog {
      font-size: 1rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .score-duck { color: #f39c12; }
    .score-frog { color: #27ae60; }
    .score-icon {
      width: 20px;
      height: 20px;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      display: inline-block;
    }
    .duck-icon { background-image: url('duck-player.png'); }
    .frog-icon { background-image: url('frog-player.png'); }
    .modal-icon {
      width: 48px;
      height: 48px;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      display: inline-block;
      vertical-align: middle;
      margin: 0 6px;
    }
    .trophy-icon { background-image: url('duck-king.png'); }
    .sad-icon { background-image: url('frog-king.png'); }
    .score-round {
      font-size: 0.8rem;
      color: #666;
    }

    /* Powers Bar - –∫–∞—É–Ω—Ç–µ—Ä + –∫–Ω–æ–ø–∫–∏ —Å–∏–ª */
    .powers-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      padding: 8px 12px;
      background: var(--bg);
      box-shadow: inset 0 4px 6px -4px var(--shadow-d);
    }
    .power-counter {
      font-size: 0.9rem;
      font-weight: 600;
      padding: 4px 10px;
      background: var(--bg);
      border-radius: 8px;
      box-shadow:
        inset 2px 2px 4px var(--shadow-d),
        inset -2px -2px 4px var(--shadow-l);
      position: relative;
    }
    .power-counter.ready {
      animation: pulse-glow 1s infinite;
      color: #f39c12;
    }
    .power-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      min-width: 18px;
      height: 18px;
      background: #e74c3c;
      color: white;
      font-size: 0.7rem;
      font-weight: 700;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .power-badge.hidden {
      display: none;
    }
    .power-btn-small {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 10px;
      background: var(--bg);
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow:
        3px 3px 6px var(--shadow-d),
        -3px -3px 6px var(--shadow-l);
      transition: all 0.15s;
    }
    .power-btn-small:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .power-btn-small:not(:disabled):active {
      box-shadow:
        inset 2px 2px 4px var(--shadow-d),
        inset -2px -2px 4px var(--shadow-l);
    }
    .power-btn-small:not(:disabled) {
      animation: power-ready 1.5s infinite;
    }
    @keyframes power-ready {
      0%, 100% { box-shadow: 3px 3px 6px var(--shadow-d), -3px -3px 6px var(--shadow-l), 0 0 0 rgba(243, 156, 18, 0); }
      50% { box-shadow: 3px 3px 6px var(--shadow-d), -3px -3px 6px var(--shadow-l), 0 0 10px rgba(243, 156, 18, 0.5); }
    }
    @keyframes pulse-glow {
      0%, 100% { box-shadow: inset 2px 2px 4px var(--shadow-d), inset -2px -2px 4px var(--shadow-l), 0 0 5px #f39c12; }
      50% { box-shadow: inset 2px 2px 4px var(--shadow-d), inset -2px -2px 4px var(--shadow-l), 0 0 12px #f39c12; }
    }

  </style>
</head>
<body>

<!-- SVG Gradient Definition -->
<svg width="0" height="0">
  <defs>
    <linearGradient id="tickGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#667eea"/>
      <stop offset="100%" stop-color="#764ba2"/>
    </linearGradient>
  </defs>
</svg>

<!-- ============ MAIN MENU SCREEN ============ -->
<div class="screen active" id="menuScreen">
  <img src="duck-vs-frog.png" alt="Duck vs Frog" class="menu-logo">
  <div class="menu-buttons">
    <button class="menu-btn primary" onclick="showScreen('selectScreen')">–ì—Ä–∞—Ç–∏ –∑ –±–æ—Ç–æ–º</button>
    <button class="menu-btn" onclick="alert('–°–∫–æ—Ä–æ –±—É–¥–µ!')">–ì—Ä–∞—Ç–∏ –∑ –¥—Ä—É–≥–æ–º</button>
    <button class="menu-btn" onclick="showScreen('settingsScreen')">–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</button>
    <button class="menu-btn" onclick="showScreen('tutorialScreen')">–Ø–∫ –≥—Ä–∞—Ç–∏</button>
  </div>
</div>

<!-- ============ CHARACTER SELECT SCREEN ============ -->
<div class="screen" id="selectScreen">
  <div class="select-container">
    <div class="select-buttons">
      <button class="select-btn duck-select" onclick="selectCharacter('duck')">
        <span class="select-icon"></span>
        <span class="select-name">–ö–∞—á–µ–Ω—è</span>
      </button>
      <button class="select-btn frog-select" onclick="selectCharacter('frog')">
        <span class="select-icon"></span>
        <span class="select-name">–ñ–∞–±–∫–∞</span>
      </button>
    </div>
    <h2 class="char-select-title" id="selectTitle">–û–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
    <button class="btn back-btn" onclick="showScreen('menuScreen')">‚Üê –ù–∞–∑–∞–¥</button>
  </div>
</div>

<!-- ============ SETTINGS SCREEN ============ -->
<div class="screen" id="settingsScreen">
  <div class="settings-container">
    <button class="btn back-btn" onclick="showScreen('menuScreen')">‚Üê –ù–∞–∑–∞–¥</button>
    <h2 class="settings-title">‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</h2>

    <div class="settings-content">
      <div class="setting-item setting-toggle">
        <div class="setting-label">üì≥ –í—ñ–±—Ä–∞—Ü—ñ—è</div>
        <div class="toggle-switch on" id="vibrationToggle" onclick="toggleVibration()"></div>
      </div>

      <div class="setting-item setting-toggle">
        <div class="setting-label">üîä –ó–≤—É–∫–∏</div>
        <div class="toggle-switch" id="soundToggle" onclick="toggleSound()"></div>
      </div>
    </div>
  </div>
</div>

<!-- ============ TUTORIAL SCREEN ============ -->
<div class="screen" id="tutorialScreen">
  <div class="tutorial-container">
    <button class="btn back-btn" onclick="showScreen('menuScreen')">‚Üê –ù–∞–∑–∞–¥</button>
    <h2 class="tutorial-title">üìñ –ü—Ä–∞–≤–∏–ª–∞ –≥—Ä–∏</h2>

    <div class="tutorial-content">
      <div class="tutorial-section">
        <h3>üéØ –ú–µ—Ç–∞</h3>
        <p>–ó–∞–±–µ—Ä–∏ —Å–≤—ñ–π —Ç–æ—Ç–µ–º (üêç –∞–±–æ ü¶Ü) –∑ –≤–æ—Ä–æ–∂–æ—ó –±–∞–∑–∏ —Ç–∞ –¥–æ–Ω–µ—Å–∏ –π–æ–≥–æ –¥–æ –∑–æ–Ω–∏ —Å–≤–æ–≥–æ –ö–æ—Ä–æ–ª—è. –ü–µ—Ä—à–∏–π —Ö—Ç–æ —Ü–µ –∑—Ä–æ–±–∏—Ç—å ‚Äî –≤–∏–≥—Ä–∞—î —Ä–∞—É–Ω–¥. –ì—Ä–∞ –¥–æ 3 –ø–µ—Ä–µ–º–æ–≥ (BO5).</p>
      </div>

      <div class="tutorial-section">
        <h3>üëÜ –ö–µ—Ä—É–≤–∞–Ω–Ω—è</h3>
        <ul>
          <li>–ö–ª—ñ–∫–Ω–∏ –Ω–∞ —Å—É—Å—ñ–¥–Ω—é –∫–ª—ñ—Ç–∏–Ω–∫—É ‚Äî —Ä—É—Ö</li>
          <li>–ö–ª—ñ–∫–Ω–∏ –Ω–∞ –≤–æ—Ä–æ–≥–∞ –ø–æ—Ä—É—á ‚Äî –∞—Ç–∞–∫–∞</li>
          <li>–ö–ª—ñ–∫–Ω–∏ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É ‚Äî –∑–ª–∞–º–∞—Ç–∏ (-1 HP)</li>
        </ul>
      </div>

      <div class="tutorial-section">
        <h3>‚ù§Ô∏è HP —Ç–∞ —Å–æ—é–∑–Ω–∏–∫–∏</h3>
        <p>–ö–æ–∂–µ–Ω —Ç–∞–∫—Ç –Ω–∞ –ø–æ–ª—ñ –∑'—è–≤–ª—è—é—Ç—å—Å—è —Å–æ—é–∑–Ω–∏–∫–∏ (üê£/üê∏). –ù–∞—Å—Ç—É–ø–∏ –Ω–∞ —Å–æ—é–∑–Ω–∏–∫–∞ —Å–≤–æ–≥–æ –∫–æ–ª—å–æ—Ä—É —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ +1 HP. –í –±–æ—é –ø–µ—Ä–µ–º–∞–≥–∞—î —Ç–æ–π, —É –∫–æ–≥–æ –±—ñ–ª—å—à–µ HP. –ü–µ—Ä–µ–º–æ–∂–µ—Ü—å –≤—Ç—Ä–∞—á–∞—î HP —Ä—ñ–≤–Ω–µ HP –ø–µ—Ä–µ–º–æ–∂–µ–Ω–æ–≥–æ.</p>
      </div>

      <div class="tutorial-section">
        <h3>‚ö° –°–∏–ª–∏ (–±–∞—Ñ–∏ —Ç–∞ –¥–µ–±–∞—Ñ–∏)</h3>
        <p>–ó–Ω–∏—â 5 –ø–µ—Ä–µ—à–∫–æ–¥ —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ —Å–∏–ª—É. –õ—ñ—á–∏–ª—å–Ω–∏–∫ –ø–æ–∫–∞–∑—É—î –ø—Ä–æ–≥—Ä–µ—Å. –ú–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –ª–∏—à–µ 1 —Å–∏–ª—É –∑–∞ —Ä–∞—É–Ω–¥.</p>
        <p style="margin-top: 8px;"><b>–ë–∞—Ñ–∏ (–Ω–∞ —Å–µ–±–µ):</b></p>
        <ul>
          <li>üê£ –°–æ—é–∑–Ω–∏–∫ ‚Äî —Å—Ç–≤–æ—Ä–∏—Ç–∏ —Å–æ—é–∑–Ω–∏–∫–∞ –Ω–∞ —Å—É—Å—ñ–¥–Ω—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ</li>
          <li>‚ö° –ü–æ–¥–≤—ñ–π–Ω–∏–π —Ö—ñ–¥ ‚Äî –∑—Ä–æ–±–∏—Ç–∏ 2 —Ö–æ–¥–∏ –∑–∞ –æ–¥–∏–Ω —Ç–∞–∫—Ç</li>
        </ul>
        <p style="margin-top: 8px;"><b>–î–µ–±–∞—Ñ–∏ (–Ω–∞ –≤–æ—Ä–æ–≥–∞):</b></p>
        <ul>
          <li>üíÄ –í–±–∏—Ç–∏ —Å–æ—é–∑–Ω–∏–∫–∞ ‚Äî –∑–Ω–∏—â–∏—Ç–∏ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ –≤–æ—Ä–æ–∂–æ–≥–æ —Å–æ—é–∑–Ω–∏–∫–∞</li>
          <li>‚ùÑÔ∏è –ó–∞–º–æ—Ä–æ–∑–∫–∞ ‚Äî –≤–æ—Ä–æ–≥ –ø—Ä–æ–ø—É—Å–∫–∞—î –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ç–∞–∫—Ç</li>
        </ul>
      </div>

      <div class="tutorial-section">
        <h3>üè∞ –¢–µ—Ä–∏—Ç–æ—Ä—ñ—è</h3>
        <p>–ü–æ–ª–µ —Ä–æ–∑–¥—ñ–ª–µ–Ω–µ –¥—ñ–∞–≥–æ–Ω–∞–ª–ª—é. –ó–≤–µ—Ä—Ö—É-—Å–ø—Ä–∞–≤–∞ —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—è –ö–∞—á–∫–∏, –∑–Ω–∏–∑—É-–∑–ª—ñ–≤–∞ ‚Äî –ñ–∞–±–∏. –ö–æ–∂–Ω–∞ —Å—Ç–æ—Ä–æ–Ω–∞ –º–∞—î —Å–≤–æ–≥–æ –ö–æ—Ä–æ–ª—è —Ç–∞ —Ç–æ—Ç–µ–º –≤–æ—Ä–æ–≥–∞ –Ω–∞ —Å–≤–æ—ó–π –±–∞–∑—ñ.</p>
      </div>
    </div>
  </div>
</div>

<!-- ============ GAME SCREEN ============ -->
<div class="screen" id="gameScreen">
  <!-- Match Score - —Ç–æ–Ω–∫–∏–π —Ä—è–¥–æ–∫ –Ω–∞–¥ –ø–æ–ª–µ–º -->
  <div class="match-score-bar" id="matchScore">
    <span class="score-frog"><span class="score-icon frog-icon"></span> <span id="frogWins">0</span></span>
    <span class="score-round">–†–∞—É–Ω–¥ <span id="roundNum">1</span></span>
    <span class="score-duck"><span id="duckWins">0</span> <span class="score-icon duck-icon"></span></span>
  </div>

  <div class="game-top">
    <div class="board-container">
      <div class="board" id="board"></div>
      <div id="allySpritesContainer"></div>
      <div class="totem-sprite snake-totem" id="snakeTotemSprite"></div>
      <div class="totem-sprite duck-totem" id="duckTotemSprite"></div>
      <div class="player-sprite" id="duckSprite"><span class="hp-badge" id="duckSpriteBadge">1</span></div>
      <div class="player-sprite" id="frogSprite"><span class="hp-badge" id="frogSpriteBadge">1</span></div>
    </div>
  </div>

  <div class="game-bottom">
    <!-- –ö–∞—É–Ω—Ç–µ—Ä + –∫–Ω–æ–ø–∫–∏ —Å–∏–ª -->
    <div class="powers-bar">
      <span class="power-counter" id="obstaclesCounter">‚ö° 0/3<span class="power-badge hidden" id="powerBadge">0</span></span>
      <button class="power-btn-small" id="powerSpawnAlly" onclick="usePower('spawnAlly')" disabled>üê£</button>
      <button class="power-btn-small" id="powerDoubleMove" onclick="usePower('doubleMove')" disabled>‚ö°</button>
      <button class="power-btn-small" id="powerKillAlly" onclick="usePower('killAlly')" disabled>üíÄ</button>
      <button class="power-btn-small" id="powerFreeze" onclick="usePower('freeze')" disabled>‚ùÑÔ∏è</button>
    </div>

    <!-- –¢–∞–∫—Ç + –º–µ–Ω—é + –ø–∞—É–∑–∞ -->
    <div class="game-panel">
      <button class="panel-btn btn-pause" id="pauseBtn" onclick="pauseGame()"></button>
      <div class="tick-ring-container">
        <svg class="tick-ring" viewBox="0 0 36 36">
          <circle class="tick-ring-bg" cx="18" cy="18" r="15.5"></circle>
          <circle class="tick-ring-progress" id="tickRing" cx="18" cy="18" r="15.5"></circle>
        </svg>
        <span class="tick-number" id="tickNumber">0</span>
      </div>
      <button class="panel-btn btn-home" onclick="goToMenu()"></button>
    </div>
  </div>
</div>

<!-- Winner Modal -->
<div class="modal" id="winModal">
  <div class="modal-content">
    <h2 id="winnerText"><span class="modal-icon trophy-icon"></span></h2>
    <p id="winnerDesc">–ü–µ—Ä–µ–º—ñ–≥!</p>
    <button class="panel-btn btn-home" style="width: 56px; height: 56px; margin: 0 auto;" onclick="goToMenu()"></button>
  </div>
</div>

<!-- Pause Modal -->
<div class="modal" id="pauseModal">
  <div class="modal-content">
    <h2>–ü–∞—É–∑–∞</h2>
    <div style="display: flex; flex-direction: row; gap: 15px; justify-content: center;">
      <button class="panel-btn btn-play" style="width: 56px; height: 56px;" onclick="resumeGame()"></button>
      <button class="panel-btn btn-home" style="width: 56px; height: 56px;" onclick="goToMenu()"></button>
    </div>
  </div>
</div>

<!-- Round Modal -->
<div class="modal" id="roundModal">
  <div class="modal-content">
    <h2 id="roundTitle">–†–∞—É–Ω–¥ 2</h2>
    <p id="roundScore"><span class="score-icon duck-icon"></span> <span id="roundDuckWins">1</span> : <span id="roundFrogWins">0</span> <span class="score-icon frog-icon"></span></p>
  </div>
</div>

<script>
// ============ CONSTANTS ============
const COLS = 9, ROWS = 15;
const TICK_MS = 1000; // 1 second per tick
const ALLY_SPAWN_TICKS = 6; // 6 sec / 1 sec = 6 ticks
const OBSTACLE_DENSITY = 0.70; // 70% chance per valid tile (more obstacles)
const MIN_OBSTACLES_PER_ZONE = 8; // –ú—ñ–Ω—ñ–º—É–º –ø–µ—Ä–µ—à–∫–æ–¥ –Ω–∞ –∫–æ–∂–Ω—É –∑–æ–Ω—É

// Diagonal divider from (col 0, row 3) to (col 8, row 11) in 0-indexed
// In 1-indexed: (1, 4) to (9, 12)

// Emoji
const EMOJI = {
  duckKing: 'üê§',
  frogKing: 'üê∏',
  duckPlayer: 'üê•',
  frogPlayer: 'üê∏',
  duckAlly: 'üê£',
  frogAlly: 'üê∏',
  snakeTotem: 'üêç',
  duckTotem: 'ü¶Ü',
  wave: 'üåä',
  bush: 'üåø'
};

// ============ GAME STATE ============
const WINS_NEEDED = 3; // BO5 = –¥–æ 3 –ø–µ—Ä–µ–º–æ–≥
const OBSTACLES_FOR_POWER = 3; // –°–∫—ñ–ª—å–∫–∏ –ø–µ—Ä–µ—à–∫–æ–¥ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑—Ä—É–π–Ω—É–≤–∞—Ç–∏ –¥–ª—è –Ω–∞–≥–æ—Ä–æ–¥–∏

let game = {
  tick: 0,
  tickTimer: null,

  humanPlayer: null, // 'duck' or 'frog'
  aiPlayer: null,    // opposite of humanPlayer

  // Match state (BO5)
  match: {
    duckWins: 0,
    frogWins: 0,
    round: 1
  },

  players: {
    duck: { row: 2, col: 6, hp: 1, hasTotem: false, targetPath: [], obstaclesDestroyed: 0, doubleMove: 0, frozen: 0, powersUsed: 0 },
    frog: { row: 12, col: 2, hp: 1, hasTotem: false, targetPath: [], obstaclesDestroyed: 0, doubleMove: 0, frozen: 0, powersUsed: 0 }
  },

  totems: {
    snake: { row: 1, col: 1, owner: 'frog', pickedBy: null },
    duck: { row: 13, col: 7, owner: 'duck', pickedBy: null }
  },

  allies: [],
  allyPaths: {}, // Store paths for visualization
  obstacles: [],
  initialObstacles: [], // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –¥–ª—è –ø–µ—Ä–µ–º—ñ—à—É–≤–∞–Ω–Ω—è

  gameOver: false,
  gameStarted: false,

  // Tick progress animation
  tickProgressTimer: null,
  tickStartTime: 0,

  // Active timeouts for cleanup
  activeTimeouts: []
};

// Safe setTimeout with cleanup tracking
function safeTimeout(callback, delay) {
  const id = setTimeout(() => {
    // Remove from active list after execution
    const idx = game.activeTimeouts.indexOf(id);
    if (idx > -1) game.activeTimeouts.splice(idx, 1);
    callback();
  }, delay);
  game.activeTimeouts.push(id);
  return id;
}

// Clear all active timeouts
function clearAllTimeouts() {
  game.activeTimeouts.forEach(id => clearTimeout(id));
  game.activeTimeouts = [];
}

// ============ HELPERS ============
const isKingTile = (r, c) => {
  // Duck king: cols 7-8, rows 0-1
  if (c >= 7 && c <= 8 && r >= 0 && r <= 1) return 'duck';
  // Frog king: cols 0-1, rows 13-14
  if (c >= 0 && c <= 1 && r >= 13 && r <= 14) return 'frog';
  return null;
};

const isKingZone = (r, c) => {
  // Duck zone: around duck king (cols 6-8, rows 0-2, excluding king)
  if (c >= 6 && c <= 8 && r >= 0 && r <= 2 && !isKingTile(r, c)) {
    if (c === 6 || r === 2) return 'duck';
  }
  // Frog zone: around frog king (cols 0-2, rows 12-14, excluding king)
  if (c >= 0 && c <= 2 && r >= 12 && r <= 14 && !isKingTile(r, c)) {
    if (c === 2 || r === 12) return 'frog';
  }
  return null;
};

// Diagonal: row = col + 3
const isDivider = (r, c) => r === c + 3;

const getTerritory = (r, c) => {
  // Above diagonal (r < c + 3) = duck territory (top-right)
  // Below diagonal (r > c + 3) = frog territory (bottom-left)
  if (r < c + 3) return 'duck';
  if (r > c + 3) return 'frog';
  return 'neutral'; // On the diagonal
};

const findObstacle = (r, c) => game.obstacles.find(o => o.row === r && o.col === c);
const findAlly = (r, c) => game.allies.find(a => a.row === r && a.col === c);
const findPlayer = (r, c) => {
  if (game.players.duck.row === r && game.players.duck.col === c) return 'duck';
  if (game.players.frog.row === r && game.players.frog.col === c) return 'frog';
  return null;
};
const findTotem = (r, c) => {
  for (let key in game.totems) {
    const t = game.totems[key];
    if (t.row === r && t.col === c && !t.pickedBy) return key;
  }
  return null;
};

const isTileBlocked = (r, c) => {
  if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return true;
  if (isKingTile(r, c)) return true;
  if (findObstacle(r, c)) return true;
  if (findPlayer(r, c)) return true;
  if (findAlly(r, c)) return true;
  return false;
};

const distance = (r1, c1, r2, c2) => Math.abs(r1 - r2) + Math.abs(c1 - c2);

// ============ INIT ============
function initGame() {
  game.tick = 0;
  game.gameOver = false;
  game.gameStarted = false;
  game.humanPlayer = null;
  game.aiPlayer = null;

  // Reset board cache for new game
  boardInitialized = false;

  // Reset match state (BO5)
  game.match = {
    duckWins: 0,
    frogWins: 0,
    round: 1
  };

  // Reset players
  game.players.duck = { row: 2, col: 6, hp: 1, hasTotem: false, targetPath: [], obstaclesDestroyed: 0, doubleMove: 0, frozen: 0, powersUsed: 0 };
  game.players.frog = { row: 12, col: 2, hp: 1, hasTotem: false, targetPath: [], obstaclesDestroyed: 0, doubleMove: 0, frozen: 0, powersUsed: 0 };

  // Reset totems
  game.totems.snake = { row: 1, col: 1, owner: 'frog', pickedBy: null };
  game.totems.duck = { row: 13, col: 7, owner: 'duck', pickedBy: null };

  // Clear allies
  game.allies = [];
  game.allyPaths = {};

  // Clear ally sprites
  const allyContainer = document.getElementById('allySpritesContainer');
  if (allyContainer) allyContainer.innerHTML = '';

  // Generate obstacles - symmetric for both sides
  game.obstacles = [];

  // Helper: check if tile is near a totem (within 2 tiles)
  const isNearSnakeTotem = (r, c) => distance(r, c, 1, 1) <= 2;
  const isNearDuckTotem = (r, c) => distance(r, c, 13, 7) <= 2;

  // Collect valid tiles - separate near-totem and far tiles
  const duckTilesNearTotem = []; // Near snake totem (duck territory, row 0 area)
  const duckTilesFar = [];
  const frogTilesNearTotem = []; // Near duck totem (frog territory, row 14 area)
  const frogTilesFar = [];

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      if (isKingZone(r, c)) continue;
      if (isDivider(r, c)) continue;

      // Don't place on player start positions
      if (r === 2 && c === 6) continue; // duck start
      if (r === 12 && c === 2) continue; // frog start

      // Don't place on totem positions
      if (r === 1 && c === 1) continue; // snake totem
      if (r === 13 && c === 7) continue; // duck totem

      const territory = getTerritory(r, c);
      if (territory === 'duck') {
        if (isNearSnakeTotem(r, c)) {
          duckTilesNearTotem.push({ row: r, col: c });
        } else {
          duckTilesFar.push({ row: r, col: c });
        }
      } else if (territory === 'frog') {
        if (isNearDuckTotem(r, c)) {
          frogTilesNearTotem.push({ row: r, col: c });
        } else {
          frogTilesFar.push({ row: r, col: c });
        }
      }
    }
  }

  // Shuffle arrays
  const shuffle = arr => {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  shuffle(duckTilesNearTotem);
  shuffle(duckTilesFar);
  shuffle(frogTilesNearTotem);
  shuffle(frogTilesFar);

  // Place equal obstacles near totems (both sides get same amount)
  // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ Math.max –¥–ª—è –≥–∞—Ä–∞–Ω—Ç—ñ—ó –º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ—ó –∫—ñ–ª—å–∫–æ—Å—Ç—ñ
  const nearTotemCount = Math.max(
    MIN_OBSTACLES_PER_ZONE,
    Math.min(
      Math.floor(duckTilesNearTotem.length * OBSTACLE_DENSITY),
      Math.floor(frogTilesNearTotem.length * OBSTACLE_DENSITY)
    )
  );

  for (let i = 0; i < nearTotemCount; i++) {
    if (duckTilesNearTotem[i]) {
      game.obstacles.push({ row: duckTilesNearTotem[i].row, col: duckTilesNearTotem[i].col, type: 'wave' });
    }
    if (frogTilesNearTotem[i]) {
      game.obstacles.push({ row: frogTilesNearTotem[i].row, col: frogTilesNearTotem[i].col, type: 'bush' });
    }
  }

  // Place equal obstacles in far areas
  const farCount = Math.max(
    MIN_OBSTACLES_PER_ZONE,
    Math.min(
      Math.floor(duckTilesFar.length * OBSTACLE_DENSITY),
      Math.floor(frogTilesFar.length * OBSTACLE_DENSITY)
    )
  );

  for (let i = 0; i < farCount; i++) {
    if (duckTilesFar[i]) {
      game.obstacles.push({ row: duckTilesFar[i].row, col: duckTilesFar[i].col, type: 'wave' });
    }
    if (frogTilesFar[i]) {
      game.obstacles.push({ row: frogTilesFar[i].row, col: frogTilesFar[i].col, type: 'bush' });
    }
  }
  
  render();
  updateHUD();
}

// ============ RENDER ============
// –ö–µ—à —Ç–∞–π–ª—ñ–≤ –¥–ª—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó
let tileCache = new Map();
let boardInitialized = false;

function initBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  tileCache.clear();

  // Kings first (images via CSS background)
  const duckKing = document.createElement('div');
  duckKing.className = 'tile king duck-king';
  boardEl.appendChild(duckKing);

  const frogKing = document.createElement('div');
  frogKing.className = 'tile king frog-king';
  boardEl.appendChild(frogKing);

  // Create all tiles once
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;

      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.row = r;
      tile.dataset.col = c;
      tile.style.gridColumn = c + 1;
      tile.style.gridRow = r + 1;

      // Zone styling (static, never changes)
      const zone = isKingZone(r, c);
      if (zone === 'duck') tile.classList.add('duck-zone');
      if (zone === 'frog') tile.classList.add('frog-zone');

      // Divider diagonal styling (static)
      if (isDivider(r, c)) tile.classList.add('divider');

      boardEl.appendChild(tile);
      tileCache.set(`${r},${c}`, tile);
    }
  }

  boardInitialized = true;
}

function render() {
  // Initialize board once
  if (!boardInitialized) {
    initBoard();
  }

  // Update ally paths for visualization
  updateAllyPaths();

  // Prepare ally path lookup (Set for O(1) lookup)
  const allyPathSet = new Map(); // key -> allyType
  for (let i = 0; i < game.allies.length; i++) {
    const path = game.allyPaths[i];
    if (path) {
      const allyType = game.allies[i].type;
      path.forEach(p => {
        const key = `${p.row},${p.col}`;
        if (!allyPathSet.has(key)) allyPathSet.set(key, allyType);
      });
    }
  }

  // Prepare human path lookup
  const humanPathSet = new Set();
  if (game.humanPlayer) {
    const humanPath = game.players[game.humanPlayer].targetPath;
    if (humanPath) {
      humanPath.forEach(p => humanPathSet.add(`${p.row},${p.col}`));
    }
  }

  // Update only changed tiles
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;

      const key = `${r},${c}`;
      const tile = tileCache.get(key);
      if (!tile) continue;

      // Reset dynamic classes
      tile.classList.remove('ally-path-duck', 'ally-path-frog', 'player-path', 'obstacle', 'wave', 'bush', 'ally', 'player');

      // Content
      let content = '';

      // Path visualization
      const allyPathType = allyPathSet.get(key);
      if (allyPathType && !findObstacle(r, c) && !findPlayer(r, c) && !findAlly(r, c)) {
        tile.classList.add(`ally-path-${allyPathType}`);
      }

      // Human player target path visualization
      if (humanPathSet.has(key)) {
        tile.classList.add('player-path');
      }

      // Obstacles
      const obstacle = findObstacle(r, c);
      if (obstacle) {
        tile.classList.add('obstacle', obstacle.type);
      }

      // Totems are now rendered as sprites, no need to show on tile

      // Allies marker
      if (findAlly(r, c)) {
        tile.classList.add('ally');
      }

      // Players marker
      if (findPlayer(r, c)) {
        tile.classList.add('player');
      }

      // Update content only if changed
      if (tile.textContent !== content) {
        tile.textContent = content;
      }
    }
  }

  // Update player sprite positions
  updatePlayerSprites();
  // Update ally sprite positions
  updateAllySprites();
}

// Update animated ally sprites
function updateAllySprites() {
  const boardEl = document.getElementById('board');
  const boardRect = boardEl.getBoundingClientRect();
  const container = document.getElementById('allySpritesContainer');
  const padding = 8;
  const gap = 3;

  const cellWidth = (boardRect.width - padding * 2 - gap * 8) / 9;
  const cellHeight = (boardRect.height - padding * 2 - gap * 14) / 15;

  // Get current sprites
  const existingSprites = container.querySelectorAll('.ally-sprite');
  const existingMap = new Map();
  existingSprites.forEach(sprite => {
    existingMap.set(sprite.dataset.allyId, sprite);
  });

  // Track which allies still exist
  const currentAllyIds = new Set();

  game.allies.forEach((ally, index) => {
    if (ally.row < 0) return; // Skip removed allies

    const allyId = ally.id || (ally.id = 'ally_' + Date.now() + '_' + index + '_' + Math.random());
    currentAllyIds.add(allyId);

    let sprite = existingMap.get(allyId);

    if (!sprite) {
      // Create new sprite (image via CSS background)
      sprite = document.createElement('div');
      sprite.className = `ally-sprite ${ally.type}-ally`;
      sprite.dataset.allyId = allyId;
      sprite.style.width = (cellWidth * 0.85) + 'px';
      sprite.style.height = (cellHeight * 0.85) + 'px';
      container.appendChild(sprite);
    }

    // Update position (with animation via CSS transition)
    const offsetX = (cellWidth - cellWidth * 0.85) / 2;
    const offsetY = (cellHeight - cellHeight * 0.85) / 2;
    sprite.style.left = (padding + ally.col * (cellWidth + gap) + offsetX) + 'px';
    sprite.style.top = (padding + ally.row * (cellHeight + gap) + offsetY) + 'px';
  });

  // Remove sprites for dead allies with fade out
  existingSprites.forEach(sprite => {
    if (!currentAllyIds.has(sprite.dataset.allyId)) {
      sprite.classList.add('dying');
      setTimeout(() => sprite.remove(), 200);
    }
  });
}

// Update animated player sprites
function updatePlayerSprites() {
  const boardEl = document.getElementById('board');
  const boardRect = boardEl.getBoundingClientRect();
  const padding = 8;
  const gap = 3;
  
  const cellWidth = (boardRect.width - padding * 2 - gap * 8) / 9;
  const cellHeight = (boardRect.height - padding * 2 - gap * 14) / 15;
  
  // Duck sprite
  const duck = game.players.duck;
  const duckSprite = document.getElementById('duckSprite');
  duckSprite.style.width = cellWidth + 'px';
  duckSprite.style.height = cellHeight + 'px';
  duckSprite.style.left = (padding + duck.col * (cellWidth + gap)) + 'px';
  duckSprite.style.top = (padding + duck.row * (cellHeight + gap)) + 'px';
  document.getElementById('duckSpriteBadge').textContent = duck.hp;
  
  // Update totem indicator (duck carries duck totem)
  let duckTotemInd = duckSprite.querySelector('.totem-indicator');
  if (duck.hasTotem) {
    if (!duckTotemInd) {
      duckTotemInd = document.createElement('span');
      duckTotemInd.className = 'totem-indicator duck-totem-ind';
      duckSprite.appendChild(duckTotemInd);
    }
  } else if (duckTotemInd) {
    duckTotemInd.remove();
  }

  // Frog sprite
  const frog = game.players.frog;
  const frogSprite = document.getElementById('frogSprite');
  frogSprite.style.width = cellWidth + 'px';
  frogSprite.style.height = cellHeight + 'px';
  frogSprite.style.left = (padding + frog.col * (cellWidth + gap)) + 'px';
  frogSprite.style.top = (padding + frog.row * (cellHeight + gap)) + 'px';
  document.getElementById('frogSpriteBadge').textContent = frog.hp;

  // Update totem indicator (frog carries frog/snake totem)
  let frogTotemInd = frogSprite.querySelector('.totem-indicator');
  if (frog.hasTotem) {
    if (!frogTotemInd) {
      frogTotemInd = document.createElement('span');
      frogTotemInd.className = 'totem-indicator frog-totem-ind';
      frogSprite.appendChild(frogTotemInd);
    }
  } else if (frogTotemInd) {
    frogTotemInd.remove();
  }

  // Update totem sprites
  updateTotemSprites(cellWidth, cellHeight, padding, gap);
}

// Update animated totem sprites
function updateTotemSprites(cellWidth, cellHeight, padding, gap) {
  const snakeTotem = game.totems.snake;
  const snakeSprite = document.getElementById('snakeTotemSprite');

  if (snakeTotem.pickedBy) {
    snakeSprite.classList.add('hidden');
  } else {
    snakeSprite.classList.remove('hidden');
    snakeSprite.style.width = cellWidth + 'px';
    snakeSprite.style.height = cellHeight + 'px';
    snakeSprite.style.fontSize = (cellHeight * 0.5) + 'px';
    snakeSprite.style.left = (padding + snakeTotem.col * (cellWidth + gap)) + 'px';
    snakeSprite.style.top = (padding + snakeTotem.row * (cellHeight + gap)) + 'px';
  }

  const duckTotem = game.totems.duck;
  const duckTotemSprite = document.getElementById('duckTotemSprite');

  if (duckTotem.pickedBy) {
    duckTotemSprite.classList.add('hidden');
  } else {
    duckTotemSprite.classList.remove('hidden');
    duckTotemSprite.style.width = cellWidth + 'px';
    duckTotemSprite.style.height = cellHeight + 'px';
    duckTotemSprite.style.fontSize = (cellHeight * 0.5) + 'px';
    duckTotemSprite.style.left = (padding + duckTotem.col * (cellWidth + gap)) + 'px';
    duckTotemSprite.style.top = (padding + duckTotem.row * (cellHeight + gap)) + 'px';
  }
}

function updateHUD() {
  // Update tick number in ring
  const tickNumber = document.getElementById('tickNumber');
  if (tickNumber) {
    tickNumber.textContent = game.tick;
  }
}

// ============ GAME LOGIC ============
function handleTileClick(r, c) {
  if (game.gameOver || !game.gameStarted) return;
  if (!game.humanPlayer) return;

  const player = game.players[game.humanPlayer];

  // Can't click on kings
  if (isKingTile(r, c)) return;

  // Can't click on same tile
  if (player.row === r && player.col === c) return;

  // –í–∏–∑–Ω–∞—á–∞—î–º–æ —á–∏ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É
  const clickedObstacle = findObstacle(r, c);

  let path;
  if (clickedObstacle) {
    // –Ø–∫—â–æ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –ø–µ—Ä–µ—à–∫–æ–¥—É - —à–ª—è—Ö –º–æ–∂–µ –π—Ç–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥–∏
    path = findPathForPlayer(player.row, player.col, r, c);
  } else {
    // –Ø–∫—â–æ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –ø—É—Å—Ç—É –∫–ª—ñ—Ç–∏–Ω—É - —Å–ø–æ—á–∞—Ç–∫—É —à—É–∫–∞—î–º–æ —à–ª—è—Ö –±–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥
    path = findPath(player.row, player.col, r, c, false);
    // –Ø–∫—â–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏ - —Å–ø—Ä–æ–±—É—î–º–æ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥–∏
    if (!path || path.length === 0) {
      path = findPathForPlayer(player.row, player.col, r, c);
    }
  }

  // –î–æ–∑–≤–æ–ª—è—î–º–æ —à–ª—è—Ö –≤—ñ–¥ 1 –¥–æ 5 –∫–ª—ñ—Ç–∏–Ω–æ–∫
  if (path && path.length > 0 && path.length <= 5) {
    // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —à–ª—è—Ö
    player.targetPath = path;
    // –í—ñ–±—Ä–∞—Ü—ñ—è –¥–ª—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤–∏–±–æ—Ä—É
    vibrate(30);
    // –û–Ω–æ–≤–ª—é—î–º–æ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é —à–ª—è—Ö—É
    updatePathVisualization();
  }
}

// –û–Ω–æ–≤–ª—é—î –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é —à–ª—è—Ö—É –±–µ–∑ –ø–æ–≤–Ω–æ—ó –ø–µ—Ä–µ–±—É–¥–æ–≤–∏ DOM
function updatePathVisualization() {
  // –û—á–∏—Å—Ç–∏—Ç–∏ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ —à–ª—è—Ö–∏
  document.querySelectorAll('.tile.player-path').forEach(t => t.classList.remove('player-path'));

  // –ü–æ–∫–∞–∑–∞—Ç–∏ –Ω–æ–≤–∏–π —à–ª—è—Ö
  if (game.humanPlayer) {
    const humanPath = game.players[game.humanPlayer].targetPath;
    if (humanPath) {
      humanPath.forEach(p => {
        const tile = document.querySelector(`.tile[data-row="${p.row}"][data-col="${p.col}"]`);
        if (tile) tile.classList.add('player-path');
      });
    }
  }
}

function combat(attackerType, defenderType) {
  const attacker = game.players[attackerType];
  const defender = game.players[defenderType];
  
  let winner, loser;
  
  if (attacker.hp > defender.hp) {
    winner = attacker;
    loser = defender;
  } else if (defender.hp > attacker.hp) {
    winner = defender;
    loser = attacker;
  } else {
    // Random winner if equal
    if (Math.random() < 0.5) {
      winner = attacker;
      loser = defender;
    } else {
      winner = defender;
      loser = attacker;
    }
  }
  
  const loserType = loser === game.players.duck ? 'duck' : 'frog';
  
  // Winner loses HP equal to loser's HP (min 1)
  winner.hp = Math.max(1, winner.hp - loser.hp);
  
  // Loser drops totem if carrying
  if (loser.hasTotem) {
    const totemKey = loserType === 'duck' ? 'duck' : 'snake';
    game.totems[totemKey].row = loser.row;
    game.totems[totemKey].col = loser.col;
    game.totems[totemKey].pickedBy = null;
    loser.hasTotem = false;
  }
  
  // Loser respawns
  if (loserType === 'duck') {
    loser.row = 0;
    loser.col = 5;
  } else {
    loser.row = 14;
    loser.col = 3;
  }
  loser.hp = 1;
  loser.targetPath = []; // Clear path on death
}

function spawnAlly(type) {
  // Find empty tile near king
  const kingZoneTiles = [];
  
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === type && !isTileBlocked(r, c)) {
        kingZoneTiles.push({ r, c });
      }
    }
  }
  
  if (kingZoneTiles.length > 0) {
    const pos = kingZoneTiles[Math.floor(Math.random() * kingZoneTiles.length)];
    game.allies.push({ type, row: pos.r, col: pos.c });
  }
}

function updateAllyPaths() {
  game.allyPaths = {};
  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    if (ally.row < 0) continue;
    const player = game.players[ally.type];
    const path = findPath(ally.row, ally.col, player.row, player.col, false); // allies can't break obstacles
    if (path) {
      game.allyPaths[i] = path;
    }
  }
}

function moveAllies() {
  game.allyPaths = {}; // Clear paths

  for (let i = 0; i < game.allies.length; i++) {
    const ally = game.allies[i];
    if (ally.row < 0) continue; // Skip already removed

    const player = game.players[ally.type];
    const enemyType = ally.type === 'duck' ? 'frog' : 'duck';
    const enemyPlayer = game.players[enemyType];

    // If reached own player (adjacent), add HP
    if (distance(ally.row, ally.col, player.row, player.col) <= 1) {
      player.hp++;
      ally.row = -100; // Mark for removal
      continue;
    }

    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –≤–æ—Ä–æ–∂–∏–π –≥—Ä–∞–≤–µ—Ü—å –Ω–∞ —Å—É—Å—ñ–¥–Ω—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ - –∞—Ç–∞–∫—É—î–º–æ!
    if (distance(ally.row, ally.col, enemyPlayer.row, enemyPlayer.col) === 1) {
      // –°–æ—é–∑–Ω–∏–∫ –∞—Ç–∞–∫—É—î –≤–æ—Ä–æ–∂–æ–≥–æ –≥—Ä–∞–≤—Ü—è - –Ω–∞–Ω–æ—Å–∏—Ç—å 1 —à–∫–æ–¥—É
      if (enemyPlayer.hp > 1) {
        enemyPlayer.hp--;
        updateHUD();
        updatePlayerSprites();
      }
      ally.row = -100; // –°–æ—é–∑–Ω–∏–∫ –≥–∏–Ω–µ –ø—ñ—Å–ª—è –∞—Ç–∞–∫–∏
      vibrate(100);
      continue;
    }

    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î –≤–æ—Ä–æ–∂—ñ —Å–æ—é–∑–Ω–∏–∫–∏ –Ω–∞ —Å—É—Å—ñ–¥–Ω—ñ—Ö –∫–ª—ñ—Ç–∏–Ω–∫–∞—Ö
    let attackedEnemy = false;
    for (const enemyAlly of game.allies) {
      if (enemyAlly.row < 0 || enemyAlly.type === ally.type) continue;
      if (distance(ally.row, ally.col, enemyAlly.row, enemyAlly.col) === 1) {
        // –ë—ñ–π –º—ñ–∂ —Å–æ—é–∑–Ω–∏–∫–∞–º–∏ –Ω–∞ —Å—É—Å—ñ–¥–Ω—ñ—Ö –∫–ª—ñ—Ç–∏–Ω–∫–∞—Ö - 50/50
        if (Math.random() < 0.5) {
          enemyAlly.row = -100; // –í–æ—Ä–æ–≥ –≥–∏–Ω–µ
        } else {
          ally.row = -100; // –ù–∞—à –≥–∏–Ω–µ
        }
        attackedEnemy = true;
        break;
      }
    }
    if (attackedEnemy || ally.row < 0) continue;

    // Use BFS to find optimal path - allies CAN'T break obstacles (false parameter)
    // If path is blocked by obstacles, ally won't move
    const path = findPath(ally.row, ally.col, player.row, player.col, false);
    if (path && path.length > 0) {
      const nextStep = path[0];

      // Check for enemy ally on next step - battle!
      const enemyAlly = findAlly(nextStep.row, nextStep.col);
      if (enemyAlly && enemyAlly.type !== ally.type) {
        // 50/50 random battle between allies
        if (Math.random() < 0.5) {
          // Current ally wins - enemy dies
          enemyAlly.row = -100;
        } else {
          // Enemy ally wins - current ally dies
          ally.row = -100;
        }
        continue;
      }

      // Check if next step is free from obstacles
      // –°–≤–æ—ó —Å–æ—é–∑–Ω–∏–∫–∏ –º–æ–∂—É—Ç—å –±—É—Ç–∏ –Ω–∞ —Ç—ñ–π –∂–µ –∫–ª—ñ—Ç–∏–Ω—Ü—ñ (–π–¥—É—Ç—å –ø–æ –æ–¥–Ω–æ–º—É —à–ª—è—Ö—É)
      if (!findObstacle(nextStep.row, nextStep.col)) {
        // Store path for visualization
        game.allyPaths[i] = path;
        // Move to next step
        ally.row = nextStep.row;
        ally.col = nextStep.col;
      }
    }
  }

  // Remove dead/absorbed allies
  game.allies = game.allies.filter(a => a.row >= 0);
}

// Dijkstra pathfinding for players - prefers paths with fewer obstacles
function findPathForPlayer(fromR, fromC, toR, toC) {
  const OBSTACLE_COST = 3; // –ü–µ—Ä–µ—à–∫–æ–¥–∞ –∫–æ—à—Ç—É—î 3, –ø—É—Å—Ç–∞ –∫–ª—ñ—Ç–∏–Ω–∫–∞ - 1
  const EMPTY_COST = 1;

  const costs = {};
  const prev = {};
  const visited = new Set();
  const key = (r, c) => `${r},${c}`;

  // Priority queue –∑ –±—ñ–Ω–∞—Ä–Ω–æ—é –≤—Å—Ç–∞–≤–∫–æ—é (–≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–∏–π –º–∞—Å–∏–≤)
  const queue = [{ r: fromR, c: fromC, cost: 0 }];
  costs[key(fromR, fromC)] = 0;

  // –í—Å—Ç–∞–≤–∫–∞ –≤ –≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–∏–π –º–∞—Å–∏–≤ (–±—ñ–Ω–∞—Ä–Ω–∏–π –ø–æ—à—É–∫)
  const insertSorted = (item) => {
    let low = 0, high = queue.length;
    while (low < high) {
      const mid = (low + high) >>> 1;
      if (queue[mid].cost < item.cost) low = mid + 1;
      else high = mid;
    }
    queue.splice(low, 0, item);
  };

  const directions = [
    { dr: -1, dc: 0 },  // up
    { dr: 1, dc: 0 },   // down
    { dr: 0, dc: -1 },  // left
    { dr: 0, dc: 1 }    // right
  ];

  while (queue.length > 0) {
    // –ë–µ—Ä–µ–º–æ –µ–ª–µ–º–µ–Ω—Ç –∑ –Ω–∞–π–º–µ–Ω—à–æ—é –≤–∞—Ä—Ç—ñ—Å—Ç—é (–≤–∂–µ –≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–æ)
    const current = queue.shift();
    const currentKey = key(current.r, current.c);

    // –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –≤–∂–µ –≤—ñ–¥–≤—ñ–¥–∞–Ω—ñ
    if (visited.has(currentKey)) continue;
    visited.add(currentKey);

    // Found target - reconstruct path
    if (current.r === toR && current.c === toC) {
      const path = [];
      let k = currentKey;
      while (prev[k]) {
        const [r, c] = k.split(',').map(Number);
        path.unshift({ row: r, col: c });
        k = prev[k];
      }
      return path;
    }

    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const nKey = key(nr, nc);

      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      if (visited.has(nKey)) continue;

      // Can't walk through enemy player (except as target for combat)
      const playerOnTile = findPlayer(nr, nc);
      if (playerOnTile && !(nr === toR && nc === toC)) continue;

      // –í–∏–∑–Ω–∞—á–∞—î–º–æ –≤–∞—Ä—Ç—ñ—Å—Ç—å –∫–ª—ñ—Ç–∏–Ω–∫–∏
      const hasObstacle = findObstacle(nr, nc);
      const stepCost = hasObstacle ? OBSTACLE_COST : EMPTY_COST;
      const newCost = current.cost + stepCost;

      // –Ø–∫—â–æ –∑–Ω–∞–π—à–ª–∏ –¥–µ—à–µ–≤—à–∏–π —à–ª—è—Ö
      if (costs[nKey] === undefined || newCost < costs[nKey]) {
        costs[nKey] = newCost;
        prev[nKey] = currentKey;
        insertSorted({ r: nr, c: nc, cost: newCost });
      }
    }
  }

  return null;
}

// BFS pathfinding for allies - can't break obstacles, avoids other allies
function findPath(fromR, fromC, toR, toC, allowObstacles = true) {
  const visited = new Set();
  const queue = [{ r: fromR, c: fromC, path: [] }];
  visited.add(`${fromR},${fromC}`);

  const directions = [
    { dr: -1, dc: 0 },  // up
    { dr: 1, dc: 0 },   // down
    { dr: 0, dc: -1 },  // left
    { dr: 0, dc: 1 }    // right
  ];

  while (queue.length > 0) {
    const current = queue.shift();

    // Found target
    if (current.r === toR && current.c === toC) {
      return current.path;
    }

    for (const dir of directions) {
      const nr = current.r + dir.dr;
      const nc = current.c + dir.dc;
      const key = `${nr},${nc}`;

      if (visited.has(key)) continue;
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      if (isKingTile(nr, nc)) continue;
      // Allow obstacles if flag is set (player can break them)
      if (!allowObstacles && findObstacle(nr, nc)) continue;
      // –°–æ—é–∑–Ω–∏–∫–∏ –º–æ–∂—É—Ç—å –π—Ç–∏ —á–µ—Ä–µ–∑ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ —Å–æ—é–∑–Ω–∏–∫–∞–º–∏ (—Ç–æ–π –∂–µ —à–ª—è—Ö)
      // Can't walk through players (except target)
      const playerOnTile = findPlayer(nr, nc);
      if (playerOnTile && !(nr === toR && nc === toC)) continue;
      
      visited.add(key);
      const newPath = [...current.path, { row: nr, col: nc }];
      queue.push({ r: nr, c: nc, path: newPath });
    }
  }
  
  return null; // No path found
}

// Get next step only (for compatibility)
function findNextStep(fromR, fromC, toR, toC) {
  const path = findPath(fromR, fromC, toR, toC);
  return path && path.length > 0 ? path[0] : null;
}

function gameWin(playerType) {
  game.gameOver = true;
  if (game.tickTimer) clearInterval(game.tickTimer);
  if (game.tickProgressTimer) cancelAnimationFrame(game.tickProgressTimer);

  // –î–æ–¥–∞—î–º–æ –æ—á–∫–æ –ø–µ—Ä–µ–º–æ–∂—Ü—é —Ä–∞—É–Ω–¥—É
  if (playerType === 'duck') {
    game.match.duckWins++;
  } else {
    game.match.frogWins++;
  }

  updateMatchScore();

  const iconClass = playerType === 'duck' ? 'duck-icon' : 'frog-icon';
  const name = playerType === 'duck' ? '–ö–∞—á–µ–Ω—è' : '–ñ–∞–±–∫–∞';
  const isHuman = playerType === game.humanPlayer;

  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Ü–µ —Ñ—ñ–Ω–∞–ª—å–Ω–∞ –ø–µ—Ä–µ–º–æ–≥–∞ –≤ –º–∞—Ç—á—ñ
  if (game.match.duckWins >= WINS_NEEDED || game.match.frogWins >= WINS_NEEDED) {
    // –§—ñ–Ω–∞–ª—å–Ω–∞ –ø–µ—Ä–µ–º–æ–≥–∞ –≤ –º–∞—Ç—á—ñ!
    if (isHuman) {
      document.getElementById('winnerText').innerHTML = `<span class="modal-icon trophy-icon"></span> <span class="modal-icon ${iconClass}"></span> –ü–µ—Ä–µ–º–æ–≥–∞ –≤ –º–∞—Ç—á—ñ!`;
      document.getElementById('winnerDesc').textContent = `${game.match.duckWins} : ${game.match.frogWins}`;
    } else {
      document.getElementById('winnerText').innerHTML = `<span class="modal-icon ${iconClass}"></span> –ü—Ä–æ–≥—Ä–∞—à`;
      document.getElementById('winnerDesc').textContent = `${game.match.duckWins} : ${game.match.frogWins}`;
    }
    document.getElementById('winModal').classList.add('show');
  } else {
    // –©–µ –Ω–µ –∫—ñ–Ω–µ—Ü—å –º–∞—Ç—á—É - –ø–æ–∫–∞–∑—É—î–º–æ –º–æ–¥–∞–ª–∫—É —Ä–∞—É–Ω–¥—É —ñ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ
    game.match.round++;
    document.getElementById('roundTitle').textContent = `–†–∞—É–Ω–¥ ${game.match.round}`;
    document.getElementById('roundDuckWins').textContent = game.match.duckWins;
    document.getElementById('roundFrogWins').textContent = game.match.frogWins;
    document.getElementById('roundModal').classList.add('show');

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ—á–∏–Ω–∞—î–º–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ä–∞—É–Ω–¥ —á–µ—Ä–µ–∑ 1.5 —Å–µ–∫—É–Ω–¥–∏
    setTimeout(() => {
      startNextRound();
    }, 1500);
  }
}

function updateMatchScore() {
  document.getElementById('duckWins').textContent = game.match.duckWins;
  document.getElementById('frogWins').textContent = game.match.frogWins;
  document.getElementById('roundNum').textContent = game.match.round;
}

function startNextRound() {
  document.getElementById('roundModal').classList.remove('show');

  // –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω —Ä–∞—É–Ω–¥—É (–∞–ª–µ –Ω–µ –º–∞—Ç—á—É!)
  resetRound();

  // –ó–∞–ø—É—Å–∫–∞—î–º–æ –∑–≤–æ—Ä–æ—Ç–Ω—ñ–π –≤—ñ–¥–ª—ñ–∫ –ø–µ—Ä–µ–¥ –Ω–∞—Å—Ç—É–ø–Ω–∏–º —Ä–∞—É–Ω–¥–æ–º
  startCountdown(() => {
    game.gameStarted = true;
    startGameTick();
  });
}

function resetRound() {
  game.tick = 0;
  game.gameOver = false;
  game.gameStarted = false;

  // –û—á–∏—â—É—î–º–æ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ —Ç–∞–π–º–µ—Ä–∏
  clearAllTimeouts();

  // –°–∫–∏–¥–∞—î–º–æ –≥—Ä–∞–≤—Ü—ñ–≤ (–≤–∫–ª—é—á–Ω–æ –∑ –≤–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—è–º–∏ —Å–∏–ª–∏)
  game.players.duck = { row: 2, col: 6, hp: 1, hasTotem: false, targetPath: [], obstaclesDestroyed: 0, doubleMove: 0, frozen: 0, powersUsed: 0 };
  game.players.frog = { row: 12, col: 2, hp: 1, hasTotem: false, targetPath: [], obstaclesDestroyed: 0, doubleMove: 0, frozen: 0, powersUsed: 0 };
  updateObstaclesCounter();

  // –°–∫–∏–¥–∞—î–º–æ —Ç–æ—Ç–µ–º–∏
  game.totems.snake = { row: 1, col: 1, owner: 'frog', pickedBy: null };
  game.totems.duck = { row: 13, col: 7, owner: 'duck', pickedBy: null };

  // –û—á–∏—â—É—î–º–æ —Å–æ—é–∑–Ω–∏–∫—ñ–≤
  game.allies = [];
  game.allyPaths = {};
  const allyContainer = document.getElementById('allySpritesContainer');
  if (allyContainer) allyContainer.innerHTML = '';

  // –ü–µ—Ä–µ–º—ñ—à—É—î–º–æ –ø–µ—Ä–µ—à–∫–æ–¥–∏ (–Ω–µ –≥–µ–Ω–µ—Ä—É—î–º–æ –Ω–æ–≤—ñ!)
  shuffleObstacles();

  updateMatchScore();
  render();
  updateHUD();
}

function shuffleObstacles() {
  // –†–æ–∑–¥—ñ–ª—è—î–º–æ –ø–µ—Ä–µ—à–∫–æ–¥–∏ –ø–æ —Ç–∏–ø–∞—Ö (wave = –∫–∞—á–∫–∞, bush = –∂–∞–±–∞)
  const waveObstacles = game.obstacles.filter(o => o.type === 'wave');
  const bushObstacles = game.obstacles.filter(o => o.type === 'bush');

  // –ó–±–∏—Ä–∞—î–º–æ –≤–∞–ª—ñ–¥–Ω—ñ –ø–æ–∑–∏—Ü—ñ—ó –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—ó
  const duckPositions = []; // –¥–ª—è wave (–∫–∞—á–∏–Ω–∞ —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—è)
  const frogPositions = []; // –¥–ª—è bush (–∂–∞–±'—è—á–∞ —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—è)

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingTile(r, c)) continue;
      if (isKingZone(r, c)) continue;
      if (isDivider(r, c)) continue;
      if (r === 2 && c === 6) continue; // duck start
      if (r === 12 && c === 2) continue; // frog start
      if (r === 1 && c === 1) continue; // snake totem
      if (r === 13 && c === 7) continue; // duck totem

      const territory = getTerritory(r, c);
      if (territory === 'duck') {
        duckPositions.push({ row: r, col: c });
      } else if (territory === 'frog') {
        frogPositions.push({ row: r, col: c });
      }
    }
  }

  // –ü–µ—Ä–µ–º—ñ—à—É—î–º–æ –ø–æ–∑–∏—Ü—ñ—ó –æ–∫—Ä–µ–º–æ –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—ó
  for (let i = duckPositions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [duckPositions[i], duckPositions[j]] = [duckPositions[j], duckPositions[i]];
  }
  for (let i = frogPositions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [frogPositions[i], frogPositions[j]] = [frogPositions[j], frogPositions[i]];
  }

  // –°—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤—ñ –ø–µ—Ä–µ—à–∫–æ–¥–∏ –Ω–∞ –Ω–æ–≤–∏—Ö –ø–æ–∑–∏—Ü—ñ—è—Ö
  game.obstacles = [];

  // Wave (—Ö–≤–∏–ª—ñ) - –∫–∞—á–∏–Ω–∞ —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—è
  for (let i = 0; i < waveObstacles.length && i < duckPositions.length; i++) {
    game.obstacles.push({
      row: duckPositions[i].row,
      col: duckPositions[i].col,
      type: 'wave'
    });
  }

  // Bush (–∫—É—â—ñ) - –∂–∞–±'—è—á–∞ —Ç–µ—Ä–∏—Ç–æ—Ä—ñ—è
  for (let i = 0; i < bushObstacles.length && i < frogPositions.length; i++) {
    game.obstacles.push({
      row: frogPositions[i].row,
      col: frogPositions[i].col,
      type: 'bush'
    });
  }
}

function closeModal() {
  document.getElementById('winModal').classList.remove('show');
}

// ============ POWERS (BUFFS/DEBUFFS) ============
function updateObstaclesCounter() {
  const counter = document.getElementById('obstaclesCounter');
  const badge = document.getElementById('powerBadge');
  if (!counter) return;

  const player = game.players[game.humanPlayer];
  if (!player) {
    counter.childNodes[0].textContent = `‚ö° 0/${OBSTACLES_FOR_POWER}`;
    if (badge) {
      badge.classList.add('hidden');
    }
    enablePowerButtons(false);
    return;
  }

  const destroyed = player.obstaclesDestroyed || 0;
  const used = player.powersUsed || 0;
  const count = destroyed % OBSTACLES_FOR_POWER;
  const powersAvailable = Math.floor(destroyed / OBSTACLES_FOR_POWER) - used;

  counter.childNodes[0].textContent = `‚ö° ${count}/${OBSTACLES_FOR_POWER}`;

  // –û–Ω–æ–≤–ª—é—î–º–æ –±–µ–π–¥–∂ –∑ –∫—ñ–ª—å–∫—ñ—Å—Ç—é –¥–æ—Å—Ç—É–ø–Ω–∏—Ö —Å–∏–ª
  if (badge) {
    if (powersAvailable > 0) {
      badge.textContent = powersAvailable;
      badge.classList.remove('hidden');
    } else {
      badge.classList.add('hidden');
    }
  }

  // –Ø–∫—â–æ —î –¥–æ—Å—Ç—É–ø–Ω—ñ —Å–∏–ª–∏ - –ø—ñ–¥—Å–≤—ñ—á—É—î–º–æ –∫–∞—É–Ω—Ç–µ—Ä —ñ –∞–∫—Ç–∏–≤—É—î–º–æ –∫–Ω–æ–ø–∫–∏
  if (powersAvailable > 0) {
    counter.classList.add('ready');
    enablePowerButtons(true);
  } else {
    counter.classList.remove('ready');
    enablePowerButtons(false);
  }
}

function enablePowerButtons(enabled) {
  document.getElementById('powerSpawnAlly').disabled = !enabled;
  document.getElementById('powerDoubleMove').disabled = !enabled;
  document.getElementById('powerKillAlly').disabled = !enabled;
  document.getElementById('powerFreeze').disabled = !enabled;
}

function checkPowerReady(playerType) {
  const player = game.players[playerType];
  if (player.obstaclesDestroyed > 0 && player.obstaclesDestroyed % OBSTACLES_FOR_POWER === 0) {
    // –ì—Ä–∞–≤–µ—Ü—å –æ—Ç—Ä–∏–º–∞–≤ –Ω–∞–≥–æ—Ä–æ–¥—É!
    if (playerType === game.humanPlayer) {
      // –õ—é–¥–∏–Ω–∞ - –∞–∫—Ç–∏–≤—É—î–º–æ –∫–Ω–æ–ø–∫–∏
      vibrate(200);
      updateObstaclesCounter();
    } else {
      // AI - –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –≤–∏–±—ñ—Ä
      aiSelectPower();
    }
  }
}

function usePower(power) {
  const human = game.players[game.humanPlayer];
  const ai = game.players[game.aiPlayer];

  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î –¥–æ—Å—Ç—É–ø–Ω—ñ —Å–∏–ª–∏
  const powersAvailable = Math.floor(human.obstaclesDestroyed / OBSTACLES_FOR_POWER) - (human.powersUsed || 0);
  if (powersAvailable <= 0) return;

  // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å–∏–ª—É
  human.powersUsed = (human.powersUsed || 0) + 1;

  switch (power) {
    case 'spawnAlly':
      spawnAlly(game.humanPlayer);
      break;

    case 'doubleMove':
      human.doubleMove = 2; // 2 —Ç—ñ–∫–∏ –ø–æ–¥–≤—ñ–π–Ω–æ–≥–æ —Ö–æ–¥—É
      break;

    case 'killAlly':
      const enemyAllies = game.allies.filter(a => a.type === game.aiPlayer && a.row >= 0);
      if (enemyAllies.length > 0) {
        enemyAllies.sort((a, b) =>
          distance(a.row, a.col, ai.row, ai.col) - distance(b.row, b.col, ai.row, ai.col)
        );
        enemyAllies[0].row = -100;
        game.allies = game.allies.filter(a => a.row >= 0);
      }
      break;

    case 'freeze':
      ai.frozen = 2; // 2 —Ç—ñ–∫–∏ –∑–∞–º–æ—Ä–æ–∑–∫–∏
      break;
  }

  vibrate(100);
  updateObstaclesCounter();
  render();
  updateHUD();
  updateAllySprites();
}

function aiSelectPower() {
  const human = game.players[game.humanPlayer];
  const ai = game.players[game.aiPlayer];

  // AI –ª–æ–≥—ñ–∫–∞ –≤–∏–±–æ—Ä—É —Å–∏–ª–∏
  const humanAllies = game.allies.filter(a => a.type === game.humanPlayer && a.row >= 0);
  const aiAllies = game.allies.filter(a => a.type === game.aiPlayer && a.row >= 0);

  // –Ø–∫—â–æ —É –ª—é–¥–∏–Ω–∏ —î —Å–æ—é–∑–Ω–∏–∫–∏ —ñ AI —Å–ª–∞–±—à–∏–π - –≤–±–∏—Ç–∏ —Å–æ—é–∑–Ω–∏–∫–∞
  if (humanAllies.length > 0 && ai.hp <= human.hp) {
    // –ó–Ω–∏—â–∏—Ç–∏ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ –¥–æ –≥—Ä–∞–≤—Ü—è —Å–æ—é–∑–Ω–∏–∫–∞
    humanAllies.sort((a, b) =>
      distance(a.row, a.col, human.row, human.col) - distance(b.row, b.col, human.row, human.col)
    );
    humanAllies[0].row = -100;
    game.allies = game.allies.filter(a => a.row >= 0);
    return;
  }

  // –Ø–∫—â–æ –ª—é–¥–∏–Ω–∞ –º–∞—î —Ç–æ—Ç–µ–º - –∑–∞–º–æ—Ä–æ–∑–∏—Ç–∏
  if (human.hasTotem) {
    human.frozen = 2; // 2 —Ç—ñ–∫–∏ –∑–∞–º–æ—Ä–æ–∑–∫–∏
    return;
  }

  // –Ø–∫—â–æ AI –º–∞—î —Ç–æ—Ç–µ–º - –ø—Ä–∏—Å–∫–æ—Ä–µ–Ω–Ω—è
  if (ai.hasTotem) {
    ai.doubleMove = 2; // 2 —Ç—ñ–∫–∏ –ø–æ–¥–≤—ñ–π–Ω–æ–≥–æ —Ö–æ–¥—É
    return;
  }

  // –Ü–Ω–∞–∫—à–µ - —Å–ø–∞–≤–Ω —Å–æ—é–∑–Ω–∏–∫–∞
  spawnAlly(game.aiPlayer);
}

function resetGame() {
  closeModal();
  if (game.tickTimer) clearInterval(game.tickTimer);
  
  // Reset AI indicator
  document.querySelectorAll('.player-info').forEach(el => el.classList.remove('ai'));
  
  // Show character selection
  document.getElementById('selectModal').classList.add('show');
  
  initGame();
}

// ============ START ============
function selectCharacter(character) {
  game.humanPlayer = character;
  game.aiPlayer = character === 'duck' ? 'frog' : 'duck';

  // Show game screen
  showScreen('gameScreen');

  // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ç—á—É —Ç–∞ –∫–∞—É–Ω—Ç–µ—Ä —Å–∏–ª
  updateMatchScore();
  updateObstaclesCounter();

  render();
  updateHUD();

  // –ó–∞–ø—É—Å–∫–∞—î–º–æ –∑–≤–æ—Ä–æ—Ç–Ω—ñ–π –≤—ñ–¥–ª—ñ–∫ –ø–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º –≥—Ä–∏
  startCountdown(() => {
    game.gameStarted = true;
    startGameTick();
  });
}

function startCountdown(callback) {
  const tickNumber = document.getElementById('tickNumber');
  const tickRing = document.getElementById('tickRing');
  const RING_CIRCUMFERENCE = 97.39;
  let count = 3;

  function showNumber() {
    tickNumber.textContent = count;

    // –ê–Ω—ñ–º–∞—Ü—ñ—è –∫—ñ–ª—å—Ü—è - –∑–∞–ø–æ–≤–Ω—é—î—Ç—å—Å—è –∑–∞ 1 —Å–µ–∫—É–Ω–¥—É
    tickRing.style.transition = 'none';
    tickRing.style.strokeDashoffset = RING_CIRCUMFERENCE;

    requestAnimationFrame(() => {
      tickRing.style.transition = 'stroke-dashoffset 1s linear';
      tickRing.style.strokeDashoffset = 0;
    });

    vibrate(50);

    if (count > 0) {
      count--;
      setTimeout(showNumber, 1000);
    } else {
      // –í—ñ–¥–ª—ñ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–æ
      vibrate(100);
      tickNumber.textContent = '0';
      if (callback) callback();
    }
  }

  showNumber();
}

function startGameTick() {
  if (game.tickTimer) clearInterval(game.tickTimer);
  if (game.tickProgressTimer) cancelAnimationFrame(game.tickProgressTimer);

  const RING_CIRCUMFERENCE = 97.39; // 2 * PI * 15.5
  const tickRing = document.getElementById('tickRing');

  // Reset ring progress
  tickRing.style.strokeDashoffset = RING_CIRCUMFERENCE;

  // Start tick timer
  game.tickStartTime = performance.now();

  game.tickTimer = setInterval(() => {
    if (!game.gameOver && game.gameStarted) {
      gameTick();
      // Reset progress after tick
      game.tickStartTime = performance.now();
      tickRing.style.transition = 'none';
      tickRing.style.strokeDashoffset = RING_CIRCUMFERENCE;
      // Re-enable transition after reflow
      requestAnimationFrame(() => {
        tickRing.style.transition = 'stroke-dashoffset 0.05s linear';
      });
    }
  }, TICK_MS);

  // Start progress animation
  updateTickProgress();
}

function updateTickProgress() {
  if (game.gameOver || !game.gameStarted) return;

  const RING_CIRCUMFERENCE = 97.39;
  const tickRing = document.getElementById('tickRing');
  const elapsed = performance.now() - game.tickStartTime;
  const progress = Math.min(elapsed / TICK_MS, 1);

  // Ring fills clockwise (offset decreases from full to 0)
  tickRing.style.strokeDashoffset = RING_CIRCUMFERENCE * (1 - progress);

  game.tickProgressTimer = requestAnimationFrame(updateTickProgress);
}

function gameTick() {
  game.tick++;

  // Spawn allies every 4 ticks
  if (game.tick % ALLY_SPAWN_TICKS === 0) {
    spawnAlly('duck');
    spawnAlly('frog');
  }

  // Move allies
  moveAllies();

  // Move human player one step if has path
  if (game.humanPlayer) {
    const human = game.players[game.humanPlayer];

    // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ —Ñ—Ä—ñ–∑
    if (human.frozen > 0) {
      human.frozen--; // –ó–º–µ–Ω—à—É—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ —Ñ—Ä—ñ–∑—É
    } else {
      movePlayerOneStep(game.humanPlayer);

      // –ü–æ–¥–≤—ñ–π–Ω–∏–π —Ö—ñ–¥ - —Ä–æ–±–∏–º–æ –¥—Ä—É–≥–∏–π –∫—Ä–æ–∫
      if (human.doubleMove > 0) {
        movePlayerOneStep(game.humanPlayer);
        human.doubleMove--; // –ó–º–µ–Ω—à—É—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫
      }
    }
  }

  // AI makes one step
  const ai = game.players[game.aiPlayer];
  if (ai.frozen > 0) {
    ai.frozen--; // –ó–º–µ–Ω—à—É—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ —Ñ—Ä—ñ–∑—É
  } else {
    aiMove();

    // AI –ø–æ–¥–≤—ñ–π–Ω–∏–π —Ö—ñ–¥
    if (ai.doubleMove > 0) {
      aiMove();
      ai.doubleMove--; // –ó–º–µ–Ω—à—É—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫
    }
  }

  render();
  updateHUD();
}

// Move player one step along their path
function movePlayerOneStep(playerType) {
  const player = game.players[playerType];
  
  if (!player.targetPath || player.targetPath.length === 0) return;
  
  const nextStep = player.targetPath[0];
  
  // Check what's on next step
  const obstacle = findObstacle(nextStep.row, nextStep.col);
  const enemyType = findPlayer(nextStep.row, nextStep.col);
  const ally = findAlly(nextStep.row, nextStep.col);
  
  // Attack enemy player
  if (enemyType && enemyType !== playerType) {
    combat(playerType, enemyType);
    player.targetPath = []; // Clear path after combat
    return;
  }
  
  // Attack enemy ally (costs 1 HP)
  if (ally && ally.type !== playerType) {
    if (player.hp > 1) {
      player.hp--;
      // Add death animation to ally tile
      const allyTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (allyTile) {
        allyTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites();
      safeTimeout(() => {
        game.allies = game.allies.filter(a => a !== ally);
        render();
      }, 250);
    }
    player.targetPath = []; // Clear path after action
    return;
  }

  // Absorb own ally (gains 1 HP, moves through them)
  if (ally && ally.type === playerType) {
    player.hp++;
    game.allies = game.allies.filter(a => a !== ally);
    // Continue moving - don't return, let the move happen below
  }

  // Break obstacle
  if (obstacle) {
    if (player.hp > 1) {
      player.hp--;
      // Add breaking animation
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('breaking');
      }
      updateHUD();
      updatePlayerSprites(); // Update sprite HP badge
      // Remove obstacle after animation, then update counter
      safeTimeout(() => {
        game.obstacles = game.obstacles.filter(o => o !== obstacle);

        // –ó–±—ñ–ª—å—à—É—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –ø—ñ—Å–ª—è –∞–Ω—ñ–º–∞—Ü—ñ—ó
        player.obstaclesDestroyed++;
        updateObstaclesCounter();

        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –≥–æ—Ç–æ–≤–∞ —Å–∏–ª–∞
        if (player.obstaclesDestroyed > 0 && player.obstaclesDestroyed % OBSTACLES_FOR_POWER === 0) {
          checkPowerReady(playerType);
        }

        render();
      }, 250);

      // –õ–∞–º–∞–Ω–Ω—è - —Ü–µ –¥—ñ—è, –∞–ª–µ —à–ª—è—Ö –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ö–æ–¥—É
      // –ù–ï –æ—á–∏—â—É—î–º–æ —à–ª—è—Ö, –ø—Ä–æ—Å—Ç–æ –≤–∏—Ö–æ–¥–∏–º–æ
    } else {
      // Show can't break feedback
      const obstacleTile = document.querySelector(`.tile[data-row="${nextStep.row}"][data-col="${nextStep.col}"]`);
      if (obstacleTile) {
        obstacleTile.classList.add('cant-break');
        setTimeout(() => obstacleTile.classList.remove('cant-break'), 300);
      }
      // –ù–µ –º–æ–∂–µ–º–æ –∑–ª–∞–º–∞—Ç–∏ - –æ—á–∏—â—É—î–º–æ —à–ª—è—Ö
      player.targetPath = [];
    }
    return;
  }
  
  // Check if tile is blocked by something else (obstacles handled above, allies handled above)
  // Only check for out of bounds, kings, and other players
  if (nextStep.row < 0 || nextStep.row >= ROWS || nextStep.col < 0 || nextStep.col >= COLS) {
    player.targetPath = [];
    return;
  }
  if (isKingTile(nextStep.row, nextStep.col)) {
    player.targetPath = [];
    return;
  }
  // If there's still an obstacle (player couldn't break it), stop
  if (findObstacle(nextStep.row, nextStep.col)) {
    player.targetPath = [];
    return;
  }

  // Move player
  player.row = nextStep.row;
  player.col = nextStep.col;
  player.targetPath.shift(); // Remove completed step
  
  // Pick up totem
  const totemKey = findTotem(player.row, player.col);
  if (totemKey) {
    const totem = game.totems[totemKey];
    if (totem.owner === playerType && !totem.pickedBy) {
      totem.pickedBy = playerType;
      player.hasTotem = true;
      totem.row = -1;
      totem.col = -1;
    }
  }
  
  // Check win condition
  if (player.hasTotem) {
    const zone = isKingZone(player.row, player.col);
    if (zone === playerType) {
      gameWin(playerType);
    }
  }
}

// ============ AI LOGIC ============

// AI Tactics enum
const AI_TACTICS = {
  GET_TOTEM: 'get_totem',       // –ô—Ç–∏ –∑–∞ —Ç–æ—Ç–µ–º–æ–º
  RETURN_TOTEM: 'return_totem', // –ù–µ—Å—Ç–∏ —Ç–æ—Ç–µ–º –¥–æ –±–∞–∑–∏
  INTERCEPT: 'intercept',       // –ü–µ—Ä–µ—Ö–æ–ø–∏—Ç–∏ –≤–æ—Ä–æ–≥–∞ –∑ —Ç–æ—Ç–µ–º–æ–º
  COLLECT_ALLIES: 'collect',    // –ó–±–∏—Ä–∞—Ç–∏ —Å–æ—é–∑–Ω–∏–∫—ñ–≤ –¥–ª—è HP
  ATTACK: 'attack',             // –ê—Ç–∞–∫—É–≤–∞—Ç–∏ –≤–æ—Ä–æ–≥–∞
  AVOID: 'avoid'                // –£–Ω–∏–∫–∞—Ç–∏ –±–æ—é (—è–∫—â–æ —Å–ª–∞–±—à–∏–π)
};

function aiMove() {
  if (!game.aiPlayer || game.gameOver) return;

  const ai = game.players[game.aiPlayer];

  // AI –ø–µ—Ä–µ–æ—Ü—ñ–Ω—é—î —Ç–∞–∫—Ç–∏–∫—É –∫–æ–∂–µ–Ω —Ç—ñ–∫
  const tactic = evaluateAITactic();

  // –ü–ª–∞–Ω—É—î–º–æ —à–ª—è—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ —Ç–∞–∫—Ç–∏–∫–∏
  planAIPath(tactic);

  // –í–∏–∫–æ–Ω—É—î–º–æ –æ–¥–∏–Ω –∫—Ä–æ–∫
  movePlayerOneStep(game.aiPlayer);
}

function evaluateAITactic() {
  const ai = game.players[game.aiPlayer];
  const human = game.players[game.humanPlayer];
  const aiTotemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
  const humanTotemKey = game.humanPlayer === 'duck' ? 'duck' : 'snake';
  const aiTotem = game.totems[aiTotemKey];
  const humanTotem = game.totems[humanTotemKey];

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 1: –Ø–∫—â–æ AI –º–∞—î —Ç–æ—Ç–µ–º - –Ω–µ—Å—Ç–∏ –¥–æ –±–∞–∑–∏
  if (ai.hasTotem) {
    return AI_TACTICS.RETURN_TOTEM;
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 2: –Ø–∫—â–æ –≤–æ—Ä–æ–≥ –º–∞—î —Ç–æ—Ç–µ–º —ñ AI —Å–∏–ª—å–Ω—ñ—à–∏–π - –ø–µ—Ä–µ—Ö–æ–ø–ª—é–≤–∞—Ç–∏
  if (human.hasTotem && ai.hp >= human.hp) {
    const distToHuman = distance(ai.row, ai.col, human.row, human.col);
    if (distToHuman <= 6) {
      return AI_TACTICS.INTERCEPT;
    }
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 3: –Ø–∫—â–æ HP –Ω–∏–∑—å–∫–∏–π —ñ —î —Å–æ—é–∑–Ω–∏–∫–∏ –ø–æ—Ä—É—á - –∑–±–∏—Ä–∞—Ç–∏
  if (ai.hp <= 2) {
    const nearbyAlly = findNearestAlly(game.aiPlayer, ai.row, ai.col);
    if (nearbyAlly && distance(ai.row, ai.col, nearbyAlly.row, nearbyAlly.col) <= 3) {
      return AI_TACTICS.COLLECT_ALLIES;
    }
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 4: –Ø–∫—â–æ —Ç–æ—Ç–µ–º –¥–æ—Å—Ç—É–ø–Ω–∏–π - –π—Ç–∏ –∑–∞ –Ω–∏–º
  if (aiTotem.pickedBy === null) {
    return AI_TACTICS.GET_TOTEM;
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 5: –Ø–∫—â–æ AI —Å–∏–ª—å–Ω—ñ—à–∏–π - –∞—Ç–∞–∫—É–≤–∞—Ç–∏
  if (ai.hp > human.hp + 1) {
    return AI_TACTICS.ATTACK;
  }

  // –ü—Ä—ñ–æ—Ä–∏—Ç–µ—Ç 6: –ó–±–∏—Ä–∞—Ç–∏ —Å–æ—é–∑–Ω–∏–∫—ñ–≤ –¥–ª—è –ø–æ—Å–∏–ª–µ–Ω–Ω—è
  return AI_TACTICS.COLLECT_ALLIES;
}

function planAIPath(tactic) {
  const ai = game.players[game.aiPlayer];
  const human = game.players[game.humanPlayer];

  let targetR, targetC;
  let avoidObstacles = false;

  switch (tactic) {
    case AI_TACTICS.RETURN_TOTEM: {
      // –ù–µ—Å—Ç–∏ —Ç–æ—Ç–µ–º - –∑–Ω–∞–π—Ç–∏ –Ω–∞–π–∫—Ä–∞—â–∏–π —à–ª—è—Ö –¥–æ king zone
      const kingZone = findBestKingZone(game.aiPlayer, ai.row, ai.col, human);
      if (kingZone) {
        targetR = kingZone.row;
        targetC = kingZone.col;
        avoidObstacles = true; // –£–Ω–∏–∫–∞—Ç–∏ –ø–µ—Ä–µ—à–∫–æ–¥ —â–æ–± –Ω–µ –≤–∏—Ç—Ä–∞—á–∞—Ç–∏ HP
      }
      break;
    }

    case AI_TACTICS.INTERCEPT: {
      // –ü–µ—Ä–µ—Ö–æ–ø–∏—Ç–∏ –≤–æ—Ä–æ–≥–∞ - –ø–µ—Ä–µ–¥–±–∞—á–∏—Ç–∏ –∫—É–¥–∏ –≤—ñ–Ω —Ä—É—Ö–∞—î—Ç—å—Å—è
      const interceptPoint = predictInterceptPoint(human);
      if (interceptPoint) {
        targetR = interceptPoint.row;
        targetC = interceptPoint.col;
      } else {
        targetR = human.row;
        targetC = human.col;
      }
      break;
    }

    case AI_TACTICS.COLLECT_ALLIES: {
      // –ó–Ω–∞–π—Ç–∏ –Ω–∞–π–±–ª–∏–∂—á–æ–≥–æ —Å–æ—é–∑–Ω–∏–∫–∞
      const ally = findNearestAlly(game.aiPlayer, ai.row, ai.col);
      if (ally) {
        targetR = ally.row;
        targetC = ally.col;
        avoidObstacles = true;
      } else {
        // –Ø–∫—â–æ –Ω–µ–º–∞—î —Å–æ—é–∑–Ω–∏–∫—ñ–≤ - –π—Ç–∏ –∑–∞ —Ç–æ—Ç–µ–º–æ–º –∞–±–æ –¥–æ —Ü–µ–Ω—Ç—Ä—É
        const totemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
        const totem = game.totems[totemKey];
        if (totem.pickedBy === null) {
          targetR = totem.row;
          targetC = totem.col;
        }
      }
      break;
    }

    case AI_TACTICS.GET_TOTEM: {
      const totemKey = game.aiPlayer === 'duck' ? 'duck' : 'snake';
      const totem = game.totems[totemKey];
      if (totem.pickedBy === null) {
        targetR = totem.row;
        targetC = totem.col;
        // –Ø–∫—â–æ AI –¥–∞–ª—ñ –≤—ñ–¥ —Ç–æ—Ç–µ–º—É –Ω—ñ–∂ –≤–æ—Ä–æ–≥ - –π—Ç–∏ –æ–±–µ—Ä–µ–∂–Ω—ñ—à–µ (—É–Ω–∏–∫–∞—Ç–∏ –ø–µ—Ä–µ—à–∫–æ–¥)
        // –Ø–∫—â–æ AI –±–ª–∏–∂—á–µ - –º–æ–∂–µ –π—Ç–∏ –Ω–∞–ø—Ä–æ–ª–æ–º —á–µ—Ä–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥–∏
        const aiDistToTotem = distance(ai.row, ai.col, totem.row, totem.col);
        const humanDistToTotem = distance(human.row, human.col, totem.row, totem.col);
        avoidObstacles = aiDistToTotem > humanDistToTotem;
      }
      break;
    }

    case AI_TACTICS.ATTACK: {
      targetR = human.row;
      targetC = human.col;
      break;
    }

    case AI_TACTICS.AVOID: {
      // –ó–Ω–∞–π—Ç–∏ –±–µ–∑–ø–µ—á–Ω—É –ø–æ–∑–∏—Ü—ñ—é –ø–æ–¥–∞–ª—ñ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞
      const safeSpot = findSafeSpot(ai, human);
      if (safeSpot) {
        targetR = safeSpot.row;
        targetC = safeSpot.col;
        avoidObstacles = true;
      }
      break;
    }
  }

  if (targetR === undefined) return;

  // –ó–Ω–∞–π—Ç–∏ —à–ª—è—Ö
  let fullPath;
  if (avoidObstacles) {
    // –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —à–ª—è—Ö –±–µ–∑ –ø–µ—Ä–µ—à–∫–æ–¥
    fullPath = findPath(ai.row, ai.col, targetR, targetC, false);
    if (!fullPath || fullPath.length === 0) {
      fullPath = findPathForPlayer(ai.row, ai.col, targetR, targetC);
    }
  } else {
    fullPath = findPathForPlayer(ai.row, ai.col, targetR, targetC);
  }

  if (fullPath && fullPath.length > 0) {
    // AI –ø–ª–∞–Ω—É—î –Ω–∞ 1-2 –∫—Ä–æ–∫–∏ –≤–ø–µ—Ä–µ–¥
    ai.targetPath = fullPath.slice(0, 2);
  }
}

function findNearestAlly(playerType, fromR, fromC) {
  let nearest = null;
  let minDist = Infinity;

  for (const ally of game.allies) {
    if (ally.type === playerType && ally.row >= 0) {
      const d = distance(fromR, fromC, ally.row, ally.col);
      if (d < minDist) {
        minDist = d;
        nearest = ally;
      }
    }
  }

  return nearest;
}

function findBestKingZone(playerType, fromR, fromC, enemy) {
  // –ó–Ω–∞–π—Ç–∏ king zone –∫–ª—ñ—Ç–∏–Ω–∫—É —è–∫–∞ –Ω–∞–π–¥–∞–ª—ñ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞ –∞–ª–µ –±–ª–∏–∑—å–∫–æ –¥–æ AI
  let best = null;
  let bestScore = -Infinity;

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === playerType && !isTileBlocked(r, c)) {
        const distFromAI = distance(fromR, fromC, r, c);
        const distFromEnemy = distance(enemy.row, enemy.col, r, c);
        // Score: –±–ª–∏–∑—å–∫–æ –¥–æ AI + –¥–∞–ª–µ–∫–æ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞
        const score = distFromEnemy * 2 - distFromAI;
        if (score > bestScore) {
          bestScore = score;
          best = { row: r, col: c };
        }
      }
    }
  }

  return best;
}

function predictInterceptPoint(target) {
  // –ü–µ—Ä–µ–¥–±–∞—á–∏—Ç–∏ –∫—É–¥–∏ —Ä—É—Ö–∞—î—Ç—å—Å—è –≤–æ—Ä–æ–≥
  if (target.targetPath && target.targetPath.length > 0) {
    // –í–æ—Ä–æ–≥ –º–∞—î –º–∞—Ä—à—Ä—É—Ç - –ø–µ—Ä–µ—Ö–æ–ø–∏—Ç–∏ –Ω–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π —Ç–æ—á—Ü—ñ
    const lastPoint = target.targetPath[target.targetPath.length - 1];
    return { row: lastPoint.row, col: lastPoint.col };
  }

  // –Ø–∫—â–æ –≤–æ—Ä–æ–≥ –Ω–µ—Å–µ —Ç–æ—Ç–µ–º - –≤—ñ–Ω —ñ–¥–µ –¥–æ —Å–≤–æ—î—ó –±–∞–∑–∏
  if (target.hasTotem) {
    const enemyType = target === game.players.duck ? 'duck' : 'frog';
    return findNearestKingZone(enemyType, target.row, target.col);
  }

  return null;
}

function findSafeSpot(ai, enemy) {
  // –ó–Ω–∞–π—Ç–∏ –∫–ª—ñ—Ç–∏–Ω–∫—É –ø–æ–¥–∞–ª—ñ –≤—ñ–¥ –≤–æ—Ä–æ–≥–∞
  let best = null;
  let maxDist = 0;

  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–ª—ñ—Ç–∏–Ω–∫–∏ –≤ —Ä–∞–¥—ñ—É—Å—ñ 3
  for (let dr = -3; dr <= 3; dr++) {
    for (let dc = -3; dc <= 3; dc++) {
      const r = ai.row + dr;
      const c = ai.col + dc;

      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) continue;
      if (isKingTile(r, c)) continue;
      if (findObstacle(r, c)) continue;
      if (findPlayer(r, c)) continue;

      const distFromEnemy = distance(r, c, enemy.row, enemy.col);
      if (distFromEnemy > maxDist) {
        maxDist = distFromEnemy;
        best = { row: r, col: c };
      }
    }
  }

  return best;
}

function findNearestKingZone(playerType, fromR, fromC) {
  let nearest = null;
  let minDist = Infinity;

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (isKingZone(r, c) === playerType && !isTileBlocked(r, c)) {
        const d = distance(fromR, fromC, r, c);
        if (d < minDist) {
          minDist = d;
          nearest = { row: r, col: c };
        }
      }
    }
  }

  return nearest;
}

// ============ SETTINGS ============
let settings = {
  vibration: true,
  sound: false
};

function loadSettings() {
  try {
    const saved = localStorage.getItem('duckVsFrogSettings');
    if (saved) {
      settings = { ...settings, ...JSON.parse(saved) };
      updateSettingsUI();
    }
  } catch (e) {}
}

function saveSettings() {
  try {
    localStorage.setItem('duckVsFrogSettings', JSON.stringify(settings));
  } catch (e) {}
}

function updateSettingsUI() {
  // Toggles
  document.getElementById('vibrationToggle').classList.toggle('on', settings.vibration);
  document.getElementById('soundToggle').classList.toggle('on', settings.sound);
}

function toggleVibration() {
  settings.vibration = !settings.vibration;
  saveSettings();
  updateSettingsUI();
  if (settings.vibration && navigator.vibrate) {
    navigator.vibrate(50);
  }
}

function toggleSound() {
  settings.sound = !settings.sound;
  saveSettings();
  updateSettingsUI();
}

// ============ SCREEN NAVIGATION ============
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(screenId).classList.add('active');
}

// ============ GAME CONTROLS ============
function pauseGame() {
  if (game.tickTimer) {
    clearInterval(game.tickTimer);
    game.tickTimer = null;
  }
  if (game.tickProgressTimer) {
    cancelAnimationFrame(game.tickProgressTimer);
    game.tickProgressTimer = null;
  }
  document.getElementById('pauseModal').classList.add('show');
}

function resumeGame() {
  document.getElementById('pauseModal').classList.remove('show');
  startGameTick();
}

function goToMenu() {
  if (game.tickTimer) {
    clearInterval(game.tickTimer);
    game.tickTimer = null;
  }
  if (game.tickProgressTimer) {
    cancelAnimationFrame(game.tickProgressTimer);
    game.tickProgressTimer = null;
  }
  document.getElementById('pauseModal').classList.remove('show');
  document.getElementById('winModal').classList.remove('show');
  showScreen('menuScreen');
  initGame();
}

function vibrate(pattern) {
  if (settings.vibration && navigator.vibrate) {
    navigator.vibrate(pattern);
  }
}

// ============ INIT ============
loadSettings();
initGame();

// –£–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –æ–±—Ä–æ–±–∫–∏ –∫–ª—ñ–∫—É/—Ç–∞—á—É –Ω–∞ –¥–æ—à—Ü—ñ
function handleBoardInteraction(clientX, clientY) {
  const board = document.getElementById('board');
  const boardRect = board.getBoundingClientRect();
  const padding = 8; // board padding
  const gap = 3; // gap –º—ñ–∂ –∫–ª—ñ—Ç–∏–Ω–∫–∞–º–∏

  // –í–Ω—É—Ç—Ä—ñ—à–Ω—è –æ–±–ª–∞—Å—Ç—å –¥–æ—à–∫–∏ (–±–µ–∑ padding)
  const innerWidth = boardRect.width - padding * 2;
  const innerHeight = boardRect.height - padding * 2;

  // –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –ø–æ–∑–∏—Ü—ñ—é –∫–ª—ñ–∫—É –≤—ñ–¥–Ω–æ—Å–Ω–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ—ó –æ–±–ª–∞—Å—Ç—ñ
  const x = clientX - boardRect.left - padding;
  const y = clientY - boardRect.top - padding;

  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–∏ –∫–ª—ñ–∫ –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –¥–æ—à–∫–∏
  if (x < 0 || y < 0 || x > innerWidth || y > innerHeight) return;

  // –†–æ–∑–º—ñ—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏ –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º gap
  // –ó–∞–≥–∞–ª—å–Ω–∞ —à–∏—Ä–∏–Ω–∞ = COLS * cellWidth + (COLS - 1) * gap
  const cellWidth = (innerWidth - (COLS - 1) * gap) / COLS;
  const cellHeight = (innerHeight - (ROWS - 1) * gap) / ROWS;

  // –†–æ–∑–º—ñ—Ä –æ–¥–Ω—ñ—î—ó "–∫–æ–º—ñ—Ä–∫–∏" (–∫–ª—ñ—Ç–∏–Ω–∫–∞ + gap)
  const cellPlusGapWidth = cellWidth + gap;
  const cellPlusGapHeight = cellHeight + gap;

  // –í–∏–∑–Ω–∞—á–∞—î–º–æ col —ñ row
  const col = Math.floor(x / cellPlusGapWidth);
  const row = Math.floor(y / cellPlusGapHeight);

  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –º–µ–∂—ñ
  if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
    handleTileClick(row, col);
  }
}

// Event delegation for board clicks
document.getElementById('board').addEventListener('click', (e) => {
  handleBoardInteraction(e.clientX, e.clientY);
});

// Touch events –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö - —à–≤–∏–¥—à–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å
let touchHandled = false;
document.getElementById('board').addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    const touch = e.touches[0];
    handleBoardInteraction(touch.clientX, touch.clientY);
    touchHandled = true;
    // –ó–∞–ø–æ–±—ñ–≥–∞—î–º–æ –ø–æ–¥–≤—ñ–π–Ω–æ–º—É —Å–ø—Ä–∞—Ü—é–≤–∞–Ω–Ω—é (touch + click)
    e.preventDefault();
  }
}, { passive: false });

document.getElementById('board').addEventListener('touchend', () => {
  // –°–∫–∏–¥–∞—î–º–æ —Ñ–ª–∞–≥ –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ç–∞—á—É
  setTimeout(() => { touchHandled = false; }, 100);
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (game.tickTimer) clearInterval(game.tickTimer);
});
</script>
</body>
</html>
